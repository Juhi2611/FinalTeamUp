MY FILES:

App.tsx:
import { Toaster } from "@/components/ui/toaster";
import { Toaster as Sonner } from "@/components/ui/sonner";
import { TooltipProvider } from "@/components/ui/tooltip";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { BrowserRouter, Routes, Route } from "react-router-dom";
import { AuthProvider } from "./contexts/AuthContext";
import Index from "./pages/Index";
import { BlockProvider } from "./contexts/BlockContext";
import NotFound from "./pages/NotFound";
import ProfilePage from "./pages/ProfilePage";
import TeamDetails from "./pages/TeamDetails";
import TeamFiles from "./components/pages/TeamFiles";

const queryClient = new QueryClient();

const App = () => (
  <QueryClientProvider client={queryClient}>
    <AuthProvider>
      <BlockProvider>
        <TooltipProvider>
          <Toaster />
          <Sonner />
          <BrowserRouter>
            <Routes>
              <Route path="/" element={<Index />}>
                <Route path="team/:teamId" element={<TeamDetails />} />
              </Route>
              <Route path="/teams/:teamId/files" element={<TeamFiles />} />

              <Route path="/profile/:userId" element={<ProfilePage />} />
              <Route path="*" element={<NotFound />} />
            </Routes>
          </BrowserRouter>
        </TooltipProvider>
      </BlockProvider>
    </AuthProvider>
  </QueryClientProvider>
);

export default App;


Index.tsx:
import { useState, useEffect } from 'react';
import { Zap, Menu, X, Bell} from 'lucide-react';
import LeftSidebar from '../components/LeftSidebar';
import RightSidebar from '../components/RightSidebar';
import HomeFeed from '../components/pages/HomeFeed';
import BuildTeam from '../components/pages/BuildTeam';
import DiscoverPeople from '../components/pages/DiscoverPeople';
import DiscoverTeams from '../components/pages/DiscoverTeams';
import { AnimatePresence, motion } from 'framer-motion';
import EditTeam from '@/components/pages/EditTeam';
import { useNavigate } from 'react-router-dom';
import { toast } from 'sonner';
import MyTeams from '../components/pages/MyTeams';
import Profile from '../components/pages/Profile';
import Notifications from '../components/pages/Notifications';
import TeamWorkspace from '../components/pages/TeamWorkspace';
import Auth from '../components/pages/Auth';
import ProfileSetup from '../components/pages/ProfileSetup';
import SkillVerificationModal from '@/components/skill-verification/SkillVerificationModal';
import Messages from '@/components/pages/Messages';
import { useAuth } from '../contexts/AuthContext';
import { getProfile, subscribeToNotifications, getOrCreateConversation, UserProfile, Notification } from '../services/firestore';
import { isFirebaseConfigured } from '../lib/firebase';
import { useSidebarState } from '../hooks/useSidebarState';
import Header from '@/components/landing/Header';
import Hero from '@/components/landing/Hero';
import LogoBar from '@/components/landing/LogoBar';
import Features from '@/components/landing/Features';
import WhyChooseUs from '@/components/landing/WhyChooseUs';
import FAQ from '@/components/landing/FAQ';
import Newsletter from '@/components/landing/ContactUs';
import Footer from '@/components/landing/Footer';

const Index = () => {
  const navigate = useNavigate();
  const { user, loading: authLoading, logout } = useAuth();
  const [currentPage, setCurrentPage] = useState('feed');
  const [selectedUserId, setSelectedUserId] = useState<string | null>(null);
  const [selectedTeamId, setSelectedTeamId] = useState<string | null>(null);
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
  const [profile, setProfile] = useState<UserProfile | null>(null);
  const [needsProfileSetup, setNeedsProfileSetup] = useState(false);
  const [editingProfile, setEditingProfile] = useState(false);
  const [showLogoutConfirm, setShowLogoutConfirm] = useState(false);
  const [unreadCount, setUnreadCount] = useState(0);
  const [showVerificationModal, setShowVerificationModal] = useState(false);
  const [activeConversationId, setActiveConversationId] = useState<string | null>(null);
  const [showEntry, setShowEntry] = useState(true);
  const [forceAuth, setForceAuth] = useState(false);

  const { leftCollapsed, rightCollapsed, toggleLeft, toggleRight } = useSidebarState();

  useEffect(() => {
    if (user && isFirebaseConfigured()) {
      checkProfile();

      // Subscribe to notifications for unread count
      const unsubscribe = subscribeToNotifications(user.uid, (notifications) => {
        const unread = notifications.filter(n => !n.read).length;
        setUnreadCount(unread);
      });
      return () => unsubscribe();
    }
  }, [user]);
  useEffect(() => {
  const savedPage = localStorage.getItem('teamup:lastPage');

  const path = window.location.pathname.replace('/', '');
  const pageFromUrl = path || 'feed';

  const pageToLoad = savedPage || pageFromUrl;

  setCurrentPage(pageToLoad);

  // keep browser history in sync on refresh / direct URL
  window.history.replaceState(
    { page: pageToLoad },
    '',
    pageToLoad === 'feed' ? '/' : `/${pageToLoad}`
  );
}, []);

useEffect(() => {
  const handlePopState = (event: PopStateEvent) => {
    const page = event.state?.page || 'feed';

    setCurrentPage(page);
    setSelectedUserId(null);
    setSelectedTeamId(null);
    setEditingProfile(false);
    setActiveConversationId(null);
  };

  window.addEventListener('popstate', handlePopState);
  return () => window.removeEventListener('popstate', handlePopState);
}, []);
 const checkProfile = async () => {
  if (!user) return;

  const { ensureUserHasUsername } = await import('@/services/firestore');
  await ensureUserHasUsername(user.uid);

  const userProfile = await getProfile(user.uid);

  // üö® Profile missing ‚Üí force logout
  if (!userProfile) {
    await logout();
    toast.error('Account not found or email not registered yet');
    return;
  }

  if (!userProfile.primaryRole) {
    setNeedsProfileSetup(true);
    return;
  }

  setProfile(userProfile);
  setNeedsProfileSetup(false);
};

const handleNavigate = (page: string) => {
  setCurrentPage(page);
  setSelectedUserId(null);
  setSelectedTeamId(null);
  setMobileMenuOpen(false);
  setEditingProfile(false);
  setActiveConversationId(null);

  localStorage.setItem('teamup:lastPage', page);

  // ‚úÖ THIS IS WHAT CHANGES THE URL
  window.history.pushState(
    { page },
    '',
    page === 'feed' ? '/' : `/${page}`
  );
};

  const handleViewProfile = (userId: string) => {
    setSelectedUserId(userId);
    setCurrentPage('viewProfile');
  };

  const handleMessageUser = async (targetUserId: string) => {
    if (!user) return;
    try {
      const conversationId = await getOrCreateConversation(user.uid, targetUserId);
      setActiveConversationId(conversationId);
      setCurrentPage('messages');
    } catch (error) {
      console.error('Error starting conversation:', error);
      toast.error('Failed to start conversation');
    }
  };

  const handleNavigateToMessages = (conversationId: string) => {
    setActiveConversationId(conversationId);
    setCurrentPage('messages');
  };

  const handleViewWorkspace = (teamId: string) => {
    setSelectedTeamId(teamId);
    setCurrentPage('workspace');
  };

  const handleEditProfile = () => {
    setEditingProfile(true);
  };

  const handleOpenVerification = () => {
    setShowVerificationModal(true);
  };

  const handleVerificationComplete = () => {
    setShowVerificationModal(false);
    checkProfile(); // Refresh profile to show verified status
  };

  
  // 1Ô∏è‚É£ PUBLIC ENTRY (landing page)
    if (showEntry && !user) {
      return (
        <div className="min-h-screen bg-background">
          <Header
            onGetStarted={() => {
              setShowEntry(false);
              setForceAuth(true);
            }}
          />
          <Hero />
          <LogoBar />
          <Features />
          <WhyChooseUs />
          <FAQ />
          <Newsletter />
          <Footer />
        </div>
      );
    }

    // 2Ô∏è‚É£ AUTH SCREEN (only after Get Started)
    if ((forceAuth || !showEntry) && isFirebaseConfigured() && !authLoading && !user) {
      return <Auth onAuthSuccess={() => setForceAuth(false)} />;
    }

    // 3Ô∏è‚É£ LOADING
    if (authLoading) {
      return (
        <div className="min-h-screen bg-background flex items-center justify-center">
          <div className="text-center">
            <div className="p-2 rounded-lg bg-gradient-to-br from-primary to-primary/80 w-fit mx-auto mb-4">
              <Zap className="w-6 h-6 text-primary-foreground" />
            </div>
            <p className="text-muted-foreground">Loading...</p>
          </div>
        </div>
      );
    }

    // 4Ô∏è‚É£ PROFILE SETUP
    if ((needsProfileSetup || editingProfile) && user) {
      return (
        <ProfileSetup
          existingProfile={editingProfile ? profile : null}
          onComplete={() => {
            setNeedsProfileSetup(false);
            setEditingProfile(false);
            checkProfile();
          }}
          onOpenVerification={handleOpenVerification}
        />
      );
    }

  // Show auth if not logged in (only when Firebase is configured)
  if (isFirebaseConfigured() && !authLoading && !user) {
    return <Auth onAuthSuccess={() => {}} />;
  }

  // Show loading
  if (authLoading) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <div className="text-center">
          <div className="p-2 rounded-lg bg-gradient-to-br from-primary to-primary/80 w-fit mx-auto mb-4">
            <Zap className="w-6 h-6 text-primary-foreground" />
          </div>
          <p className="text-muted-foreground">Loading...</p>
        </div>
      </div>
    );
  }

  // Show profile setup if needed
  if ((needsProfileSetup || editingProfile) && user) {
    return (
      <ProfileSetup
        existingProfile={editingProfile ? profile : null}
        onComplete={() => {
          setNeedsProfileSetup(false);
          setEditingProfile(false);
          checkProfile();
        }}
        onOpenVerification={handleOpenVerification}
      />
    );
  }

  const renderContent = () => {
    switch (currentPage) {
      case 'feed':
        return <HomeFeed onNavigate={handleNavigate} onViewProfile={handleViewProfile} />;

      case 'build':
        return <BuildTeam onNavigate={handleNavigate} />;

      case 'discover':
        return <DiscoverPeople onViewProfile={handleViewProfile} />;

      case 'discover-teams':
        return <DiscoverTeams onNavigate={handleNavigate} />;

      case 'teams':
  return (
    <MyTeams
      onNavigate={handleNavigate}
      onViewWorkspace={handleViewWorkspace}
      onViewProfile={handleViewProfile} // ‚úÖ ADD THIS
    />
  );

      case 'notifications':
  return (
    <Notifications 
      onNavigateToMessages={handleNavigateToMessages}
      onViewProfile={handleViewProfile}
    />
  );
      case 'profile':
        return (
          <Profile
            isOwnProfile={true}
            userProfile={profile}
            onEditProfile={handleEditProfile}
            onOpenVerification={handleOpenVerification}
          />
        );
      case 'viewProfile':
        return (
          <Profile
            userId={selectedUserId || undefined}
            isOwnProfile={false}
            onMessage={handleMessageUser}
          />
        );

     case 'messages':
  return (
    <Messages
      initialConversationId={activeConversationId}
      onBack={() => handleNavigate('feed')}
      onViewProfile={handleViewProfile} // ‚úÖ ADD
    />
  );
      case 'workspace':
        return (
          <TeamWorkspace
            teamId={selectedTeamId || ''}
            onBack={() => handleNavigate('teams')}
          />
        );

      default:
        return <HomeFeed onNavigate={handleNavigate} onViewProfile={handleViewProfile} />;
    }
  };

  return (
    <div className="min-h-screen bg-background">
      {/* Header */}
      <header className="sticky top-0 z-40 bg-card border-b border-border">
        <div className="max-w-7xl mx-auto px-4 h-16 flex items-center justify-between">
          <div
  onClick={() => handleNavigate('feed')}
  className="flex items-center gap-2 cursor-pointer select-none hover:opacity-80 transition"
>
  <div className="p-1.5 rounded-lg bg-gradient-to-br from-primary to-primary/80">
    <Zap className="w-5 h-5 text-primary-foreground" />
  </div>
  <span className="font-display font-bold text-xl text-foreground">
    TeamUp
  </span>
</div>
          <div className="hidden md:flex flex-1 max-w-md mx-8">
            
          </div>
          <div className="flex items-center gap-3">
            <button
              onClick={() => handleNavigate('notifications')}
              className="p-2 rounded-lg hover:bg-secondary transition-colors relative"
            >
              <Bell className="w-5 h-5 text-muted-foreground" />
              {unreadCount > 0 && (
                <span className="absolute top-0.5 right-0.5 min-w-[18px] h-[18px] px-1 rounded-full bg-accent text-accent-foreground text-xs font-bold flex items-center justify-center">
                  {unreadCount > 9 ? '9+' : unreadCount}
                </span>
              )}
            </button>
            {user && (
<button
  onClick={() => setShowLogoutConfirm(true)}
  className="text-sm text-muted-foreground hover:text-foreground"
>
  Logout
</button>


      )}
            <button
              onClick={() => setMobileMenuOpen(!mobileMenuOpen)}
              className="md:hidden p-2 rounded-lg hover:bg-secondary transition-colors"
            >
              {mobileMenuOpen ? <X className="w-5 h-5 text-foreground" /> : <Menu className="w-5 h-5 text-foreground" />}
            </button>
          </div>
        </div>
      </header>

      {mobileMenuOpen && (
        <div className="fixed inset-0 z-30 bg-background/95 backdrop-blur-sm md:hidden pt-16">
          <div className="p-4">
            <LeftSidebar currentPage={currentPage} onNavigate={handleNavigate} userProfile={profile} />
          </div>
        </div>
      )}

      <div className="max-w-8xl mx-auto px-4 py-6">
        <div className="flex gap-6">
          <div className="hidden md:block">
            <div className="sticky top-24">
              <LeftSidebar
                currentPage={currentPage}
                onNavigate={handleNavigate}
                userProfile={profile}
                collapsed={leftCollapsed}
                onToggleCollapse={toggleLeft}
              />
            </div>
          </div>
          <main className="flex-1 min-w-0">
  <AnimatePresence mode="wait">
    <motion.div
      key={currentPage}
      initial={{ opacity: 0, y: 8 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: -6 }}
      transition={{ duration: 0.18, ease: 'easeOut' }}
      className="h-full"
    >
      {renderContent()}
    </motion.div>
  </AnimatePresence>
</main>
          <div className="hidden lg:block">
            <div className="sticky top-24">
              <RightSidebar
                onViewProfile={handleViewProfile}
                onNavigate={handleNavigate}
                collapsed={rightCollapsed}
                onToggleCollapse={toggleRight}
              />
            </div>
          </div>
        </div>
      </div>

      {/* Skill Verification Modal */}
      {showVerificationModal && user && profile && (
        <SkillVerificationModal
          open={showVerificationModal}
          onOpenChange={setShowVerificationModal}
          userSkills={profile.skills.map(skill => skill.name)}
          onVerificationComplete={handleVerificationComplete}
        />
      )}

{showLogoutConfirm && (
  <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/40 backdrop-blur-sm">
    <motion.div
      initial={{ scale: 0.9, opacity: 0 }}
      animate={{ scale: 1, opacity: 1 }}
      exit={{ scale: 0.9, opacity: 0 }}
      transition={{ duration: 0.18, ease: "easeOut" }}
      className="bg-card rounded-xl shadow-lg w-full max-w-sm p-6"
    >
      <h2 className="text-lg font-semibold text-foreground mb-2">
        Confirm Logout
      </h2>

      <p className="text-sm text-muted-foreground mb-6">
        Do you really want to exit TeamUp?
      </p>

      <div className="flex justify-end gap-3">
        <button
          onClick={() => setShowLogoutConfirm(false)}
          className="px-4 py-2 rounded-lg text-sm bg-secondary text-foreground hover:bg-secondary/80 transition"
        >
          Cancel
        </button>

        <button
          onClick={async () => {
            try {
              setShowLogoutConfirm(false);
              await logout();

              setCurrentPage('feed');
              localStorage.removeItem('teamup:lastPage');

              window.location.href = '/';
            } catch (err) {
              console.error(err);
              toast.error('Failed to logout');
            }
          }}
          className="px-4 py-2 rounded-lg text-sm bg-destructive text-destructive-foreground hover:bg-destructive/90 transition"
        >
          Logout
        </button>
      </div>
    </motion.div>
  </div>
)}

       
    </div>
  );
};
export default Index;


Profile.tsx:
import { useState, useEffect } from 'react';
import PitchModal from '../PitchModal';
import { MapPin, Calendar, Award, Quote, Sparkles, Shield, ExternalLink, Loader2, Edit, Trash2, PenSquare, CheckCircle2, ShieldCheck } from 'lucide-react';
import { useAuth } from '@/contexts/AuthContext';
import { 
  getProfile, 
  subscribeToUserPosts, 
  updatePost, 
  deletePost, 
  UserProfile, 
  FeedPost,
  getSkillVerification,
  subscribeToSkillVerification,
  SkillVerification
} from '@/services/firestore';
import { isFirebaseConfigured } from '@/lib/firebase';
import Linkify from 'linkify-react';
import { getSkillClass } from '@/data/mockData';
import { Timestamp } from 'firebase/firestore';
import EditPostModal from '../EditPostModal';
import { toast } from 'sonner';
import BlockReportModal from '../BlockReportModal';
import { useBlocks } from '@/contexts/BlockContext';
import { Flag } from 'lucide-react';
import { Camera } from 'lucide-react';
import { updateProfile, subscribeToProfile } from '@/services/firestore';
import { uploadProfilePicture } from '@/services/firestore';
import { deleteUser } from 'firebase/auth';
import { auth } from '@/lib/firebase';
import { deleteUserCompletely } from '@/services/firestore';

interface ProfileProps {
  userId?: string;
  isOwnProfile?: boolean;
  userProfile?: UserProfile | null;
  onEditProfile?: () => void;
  onOpenVerification?: () => void;
  onMessage?: (userId: string) => void;
  onProfileUpdated?: (profile: UserProfile) => void; // ‚úÖ ADD
}

const Profile = ({ userId, isOwnProfile = true, userProfile: passedProfile, onEditProfile, onOpenVerification, onMessage, onProfileUpdated }: ProfileProps) => {
  const { user } = useAuth();
  const [showBlockReportModal, setShowBlockReportModal] = useState(false);
  const { isHidden, refreshBlocks } = useBlocks();
  const [profile, setProfile] = useState<UserProfile | null>(passedProfile || null);
  const [loading, setLoading] = useState(!passedProfile);
  const [myPosts, setMyPosts] = useState<FeedPost[]>([]);
  const [postsLoading, setPostsLoading] = useState(true);
  const [editingPost, setEditingPost] = useState<FeedPost | null>(null);
  const [deletingPostId, setDeletingPostId] = useState<string | null>(null);
  const [showPitchModal, setShowPitchModal] = useState(false);

  
  // Skill verification state
  const [skillVerification, setSkillVerification] = useState<SkillVerification | null>(null);
  const [verificationLoading, setVerificationLoading] = useState(true);

  const targetUserId = userId || user?.uid;

  useEffect(() => {
  if (!targetUserId) return;

  const unsubscribe = subscribeToProfile(targetUserId, (updatedProfile) => {
    setProfile(updatedProfile);
    setLoading(false);
  });

  return () => unsubscribe();
}, [targetUserId]);

  // Subscribe to user's posts
  useEffect(() => {
    if (!isFirebaseConfigured() || !targetUserId) {
      setPostsLoading(false);
      return;
    }

    const unsubscribe = subscribeToUserPosts(targetUserId, (posts) => {
      setMyPosts(posts);
      setPostsLoading(false);
    });

    return () => unsubscribe();
  }, [targetUserId]);

  // Subscribe to skill verification
  useEffect(() => {
    if (!isFirebaseConfigured() || !targetUserId) {
      setVerificationLoading(false);
      return;
    }

    const unsubscribe = subscribeToSkillVerification(targetUserId, (verification) => {
      setSkillVerification(verification);
      setVerificationLoading(false);
    });

    return () => unsubscribe();
  }, [targetUserId]);

  const handleEditPost = async (
    postId: string,
    data: {
      title: string;
      description: string;
      tags: string[];
      image?: File | null;
      removeImage?: boolean;
    }
  ) => {
    updatePost(postId, user.uid, data);
    toast.success('Post updated successfully!');
  };

  const handleDeletePost = async (postId: string) => {
    if (!confirm('Are you sure you want to delete this post? This action cannot be undone.')) {
      return;
    }
    
    setDeletingPostId(postId);
    try {
      await deletePost(postId);
      toast.success('Post deleted successfully!');
    } catch (error: any) {
      toast.error(error.message || 'Failed to delete post');
    }
    setDeletingPostId(null);
  };
const handleDeleteProfile = async () => {
  const confirmText = prompt(
    "This will permanently delete your account.\nType DELETE to continue."
  );

  if (confirmText !== "DELETE") {
    toast("Deletion cancelled");
    return;
  }

  try {
    const currentUser = auth.currentUser;
    if (!currentUser) throw new Error("No authenticated user");

    await deleteUserCompletely(currentUser.uid);
    await deleteUser(currentUser);

    toast.success("Account deleted successfully");
    window.location.href = "/";
  } catch (err: any) {
    console.error(err);
    toast.error("Failed to delete account");
  }
};

const handleAvatarChange = async (
    e: React.ChangeEvent<HTMLInputElement>
  ) => {
    if (!e.target.files || !user) return;

    const file = e.target.files[0];

    try {
      const avatarUrl = await uploadProfilePicture(user.uid, file);

      await updateProfile(user.uid, { avatar: avatarUrl });

      // üîë FETCH FRESH PROFILE & NOTIFY PARENT
      const updatedProfile = await getProfile(user.uid);
      if (updatedProfile) {
        onProfileUpdated?.(updatedProfile);
      }

      toast.success('Profile picture updated');
    } catch (err) {
      console.error('Upload failed:', err);
      toast.error('Upload failed');
    }
  };
  const formatTimestamp = (timestamp: Timestamp | null): string => {
    if (!timestamp) return 'Just now';
    const date = timestamp.toDate();
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);
    
    if (diffMins < 1) return 'Just now';
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    return `${diffDays}d ago`;
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center p-12">
        <Loader2 className="w-8 h-8 animate-spin text-primary" />
      </div>
    );
  }

  if (!profile) {
    return (
      <div className="card-base p-12 text-center">
        <p className="text-muted-foreground">Profile not found</p>
      </div>
    );
  }

  // Check if user has verified skills
  const totalProfileSkills = profile.skills?.length || 0;
const verifiedSkillsCount = skillVerification?.verifiedSkills.length || 0;

const hasVerifiedSkills =
  skillVerification?.status === 'verified' &&
  totalProfileSkills > 0 &&
  verifiedSkillsCount === totalProfileSkills;

  return (
    <div className="space-y-6">
      {/* Header Card */}
      <div className="card-base overflow-hidden">
        <div className="h-16 bg-gradient-to-r from-primary to-primary/70" />
        <div className="px-6 pb-6">
          <div className="flex flex-col md:flex-row md:items-end md:justify-between -mt-1 gap-4">
            <div className="flex items-end gap-4">
              <div className="relative">
  <img
    src={
      profile.avatar
        ? `${profile.avatar}?t=${Date.now()}`
        : `https://api.dicebear.com/7.x/initials/svg?seed=${encodeURIComponent(
            profile.fullName || 'User'
          )}`
    }
    className="avatar w-24 h-24 border-4 border-card cursor-pointer"
    onClick={() =>
      isOwnProfile &&
      document.getElementById('avatarInput')?.click()
    }
  />

  {/* Camera Icon */}
  {isOwnProfile && (
    <button
      onClick={() =>
        document.getElementById('avatarInput')?.click()
      }
      className="absolute bottom-1 right-1 bg-white p-1.5 rounded-full shadow hover:bg-gray-100 transition"
    >
      <Camera className="w-4 h-4 text-gray-700" />
    </button>
  )}
</div>

{isOwnProfile && (
  <input
    id="avatarInput"
    type="file"
    accept="image/*"
    className="hidden"
    onChange={handleAvatarChange}
  />
)}
              <div className="mb-2">
                <div className="flex items-center gap-2 flex-wrap">
                  <h1 className="font-display font-bold text-2xl text-foreground">{profile.fullName}</h1>
                  {profile.username && (
                    <span className="text-sm text-muted-foreground">
                      @{profile.username}
                    </span>
                  )}

                  
                  {(hasVerifiedSkills || profile.teamId) && (
    <div className="flex items-center gap-2">
      {hasVerifiedSkills && (
        <span className="inline-flex items-center gap-1.5 px-2.5 py-1 rounded-full bg-[#1CB0A3]/70 border border-[#1CB0A3]/40 backdrop-blur-sm">
          <ShieldCheck className="w-4 h-4 text-white" />
          <span className="text-xs font-medium text-white">
            Skills Verified
          </span>
        </span>
      )}

      {profile.teamId && (
        <span className="inline-flex items-center gap-1.5 px-2.5 py-1 rounded-full bg-[#1CB0A3]/70 border border-[#1CB0A3]/40 backdrop-blur-sm">
          <Shield className="w-4 h-4 text-white" />
          <span className="text-xs font-medium text-white">
            In a Team
          </span>
        </span>
      )}
    </div>
  )}
</div>
                <p className="text-muted-foreground">{profile.primaryRole}</p>
                {profile.college && (
                  <p className="text-sm text-muted-foreground">{profile.college} ‚Ä¢ {profile.yearOfStudy}</p>
                )}
                {profile.city && (
                  <div className="flex items-center gap-1 text-sm text-muted-foreground mt-1">
                    <MapPin className="w-4 h-4" />
                    <span>{profile.city}</span>
                  </div>
                )}
              </div>
            </div>
            {isOwnProfile && onEditProfile && (
              <button onClick={onEditProfile} className="btn-secondary flex items-center gap-2">
                <Edit className="w-4 h-4" />
                Edit Profile
              </button>
            )}
            {!isOwnProfile && (
            <div className="flex items-center gap-2">
              <button className="btn-primary" onClick={() => setShowPitchModal(true)}>
                Pitch Your Team
              </button>

              <button onClick={() => onMessage?.(targetUserId!)} className="btn-secondary text-sm">
                Message
              </button>

              <button
                onClick={() => setShowBlockReportModal(true)}
                className="btn-secondary text-sm flex items-center gap-1.5 text-destructive"
              >
                <Flag className="w-4 h-4" />
                Block / Report
              </button>
            </div>
          )}

          </div>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Main Content */}
        <div className="lg:col-span-2 space-y-6">
          {/* Bio */}
          {profile.bio && (
            <div className="card-base p-6">
              <h2 className="section-title mb-3">About</h2>
              <p className="text-muted-foreground leading-relaxed">{profile.bio && (
                <div className="card-base p-6">
                  <h2 className="section-title mb-3">About</h2>
                  <p className="text-muted-foreground leading-relaxed">
                    <Linkify
                      options={{
                        target: '_blank',
                        rel: 'noopener noreferrer',
                        className: 'text-primary underline'
                      }}
                    >
                      {profile.bio}
                    </Linkify>
                  </p>
                </div>
              )}
              </p>
            </div>
          )}

          {/* Skills with Verification Indicator */}
          {profile.skills && profile.skills.length > 0 && (
            <div className="card-base p-6">
              <div className="flex items-center justify-between mb-4">
                <h2 className="section-title">Skills</h2>
                {hasVerifiedSkills && (
                  <span className="text-xs text-skill-mobile flex items-center gap-1">
                    <ShieldCheck className="w-3 h-3" />
                    {verifiedSkillsCount} verified
                  </span>
                )}
              </div>
              <div className="flex flex-wrap gap-2">
                {profile.skills.map((skill, idx) => {
                  const isVerified = skillVerification?.verifiedSkills.some(
                    vs => vs.toLowerCase() === skill.name.toLowerCase()
                  );
                  
                  return (
                    <span 
                      key={idx} 
                      className={`skill-tag text-sm ${getSkillClass(skill.name)} ${isVerified ? 'ring-2 ring-skill-mobile' : ''}`}
                    >
                      {isVerified && <ShieldCheck className="w-3 h-3 inline mr-1" />}
                      {skill.name}
                      <span className="ml-1 opacity-70">({skill.proficiency})</span>
                    </span>
                  );
                })}
              </div>
            </div>
          )}

          {/* My Posts Section */}
          <div className="card-base p-6">
            <div className="flex items-center justify-between mb-4">
              <h2 className="section-title flex items-center gap-2">
                <PenSquare className="w-4 h-4" />
                {isOwnProfile ? 'My Posts' : 'Posts'}
              </h2>
              <span className="text-sm text-muted-foreground">
                {myPosts.length} {myPosts.length === 1 ? 'post' : 'posts'}
              </span>
            </div>
            
            {postsLoading ? (
              <div className="flex items-center justify-center p-8">
                <Loader2 className="w-6 h-6 animate-spin text-primary" />
              </div>
            ) : myPosts.length === 0 ? (
              <div className="text-center py-8">
                <PenSquare className="w-10 h-10 text-muted-foreground mx-auto mb-3" />
                <p className="text-muted-foreground">
                  {isOwnProfile ? "You haven't created any posts yet" : "No posts yet"}
                </p>
              </div>
            ) : (
              <div className="space-y-4">
                {myPosts.map((post) => (
                  <div key={post.id} className="p-4 rounded-lg bg-secondary/30 border border-border">
                    <div className="flex items-start justify-between gap-4">
                      <div className="flex-1 min-w-0">
                        <h3 className="font-semibold text-foreground mb-1">{post.title}</h3>
                        <p className="text-sm text-muted-foreground mb-2 line-clamp-2">{post.description}</p>
                        
                        {/* Tags */}
                        {post.tags && post.tags.length > 0 && (
                          <div className="flex flex-wrap gap-1 mb-2">
                            {post.tags.map((tag, idx) => (
                              <span key={idx} className="px-2 py-0.5 rounded-full text-xs font-medium bg-secondary text-muted-foreground">
                                #{tag}
                              </span>
                            ))}
                          </div>
                        )}
                        
                        <p className="text-xs text-muted-foreground">
                          {formatTimestamp(post.createdAt)}
                        </p>
                      </div>
                      
                      {/* Edit/Delete buttons - only for own posts */}
                      {isOwnProfile && user?.uid === post.authorId && (
                        <div className="flex items-center gap-2 flex-shrink-0">
                          <button
                            onClick={() => setEditingPost(post)}
                            className="p-2 rounded-lg hover:bg-secondary transition-colors text-muted-foreground hover:text-foreground"
                            title="Edit post"
                          >
                            <Edit className="w-4 h-4" />
                          </button>
                          <button
                            onClick={() => handleDeletePost(post.id)}
                            disabled={deletingPostId === post.id}
                            className="p-2 rounded-lg hover:bg-destructive/10 transition-colors text-muted-foreground hover:text-destructive"
                            title="Delete post"
                          >
                            {deletingPostId === post.id ? (
                              <Loader2 className="w-4 h-4 animate-spin" />
                            ) : (
                              <Trash2 className="w-4 h-4" />
                            )}
                          </button>
                        </div>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>

          {/* Quote */}
          
        </div>

        {/* Sidebar */}
        <div className="space-y-6">
          {/* Status */}
          <div className="card-base p-6">
            <h2 className="section-title mb-4">Status</h2>
            <div className={`inline-flex items-center gap-2 px-3 py-1.5 rounded-full text-sm font-medium ${
              profile.teamId 
                ? 'bg-muted text-muted-foreground'
                : 'bg-skill-mobile/10 text-skill-mobile'
            }`}>
              <span className={`w-2 h-2 rounded-full ${
                profile.teamId 
                  ? 'bg-muted-foreground'
                  : 'bg-skill-mobile'
              }`} />
              {profile.teamId ? 'Currently in a team' : 'Available for teams'}
            </div>
          </div>

          {/* Education */}
          {profile.college && (
            <div className="card-base p-6">
              <h2 className="section-title mb-4">Education</h2>
              <div className="space-y-2">
                <p className="font-medium text-foreground">{profile.college}</p>
                <p className="text-sm text-muted-foreground">{profile.yearOfStudy}</p>
              </div>
            </div>
          )}

          {/* Skill Verification */}
          <div className="card-base p-6">
            <div className="flex items-center gap-2 mb-3">
              <Sparkles className="w-4 h-4 text-primary" />
              <h2 className="section-title text-sm">Skill Verification</h2>
            </div>
            
            {verificationLoading ? (
              <div className="flex items-center justify-center p-4">
                <Loader2 className="w-5 h-5 animate-spin text-primary" />
              </div>
            ) : hasVerifiedSkills ? (
              <div className="space-y-3">
                <div className="p-3 rounded-lg bg-skill-mobile/10 border border-skill-mobile/20">
                  <div className="flex items-center gap-2 mb-2">
                    <CheckCircle2 className="w-4 h-4 text-skill-mobile" />
                    <p className="text-sm font-medium text-skill-mobile">Skills Verified</p>
                  </div>
                  <p className="text-xs text-muted-foreground mb-2">
                    Verified on {skillVerification.verifiedAt?.toDate().toLocaleDateString()}
                  </p>
                  <div className="flex flex-wrap gap-1">
                    {skillVerification.verifiedSkills.slice(0, 5).map((skill, idx) => (
                      <span key={idx} className="px-2 py-0.5 rounded text-xs bg-skill-mobile/20 text-skill-mobile">
                        {skill}
                      </span>
                    ))}
                    {skillVerification.verifiedSkills.length > 5 && (
                      <span className="text-xs text-muted-foreground px-2">
                        +{skillVerification.verifiedSkills.length - 5} more
                      </span>
                    )}
                  </div>
                </div>
                
                {/* Verification Sources */}
                <div className="text-xs text-muted-foreground space-y-1">
                  {skillVerification.sources.github && (
                    <div className="flex items-center gap-1">
                      <CheckCircle2 className="w-3 h-3 text-skill-mobile" />
                      <span>GitHub verified</span>
                    </div>
                  )}
                  {skillVerification.sources.certificates && skillVerification.sources.certificates.length > 0 && (
                    <div className="flex items-center gap-1">
                      <CheckCircle2 className="w-3 h-3 text-skill-mobile" />
                      <span>{skillVerification.sources.certificates.length} certificate(s) verified</span>
                    </div>
                  )}
                </div>
              </div>
            ) : isOwnProfile ? (
              <button
                onClick={onOpenVerification}
                className="w-full p-3 rounded-lg bg-gradient-to-r from-primary/10 to-accent/10 border border-primary/20 hover:from-primary/20 hover:to-accent/20 transition-all text-left"
              >
                <p className="text-sm font-medium text-primary mb-1">Verify Your Skills</p>
                <p className="text-xs text-muted-foreground">
                  Increase credibility with GitHub or certificates
                </p>
              </button>
            ) : (
              <div className="p-3 rounded-lg bg-secondary/50 border border-border">
                <p className="text-sm text-muted-foreground">
                  Skills not verified yet
                </p>
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Edit Post Modal */}
      {editingPost && (
        <EditPostModal
          post={editingPost}
          onClose={() => setEditingPost(null)}
          onSubmit={handleEditPost}
        />
      )}
      {showPitchModal && !isOwnProfile && (
  <PitchModal
    type="pitch"
    recipientName={profile.fullName}
    recipientId={targetUserId}
    onClose={() => setShowPitchModal(false)}
    onSend={async (message) => {
      console.log('Pitch sent:', message);
      // TODO: save pitch / send notification / message
    }}
  />
)}
{showBlockReportModal && user && profile && (
  <BlockReportModal
    targetUserId={profile.id}
    targetUserName={profile.fullName || 'User'}
    currentUserId={user.uid}
    onClose={() => setShowBlockReportModal(false)}
    onBlockComplete={refreshBlocks}
  />
)}
{isOwnProfile && (
  <div className="card-base p-6 border border-destructive/30">
    <h2 className="section-title text-destructive mb-2">
      Danger Zone
    </h2>

    <button
      onClick={handleDeleteProfile}
      className="w-full mt-3 p-3 rounded-lg bg-destructive text-white"
    >
      Delete Profile Permanently
    </button>

    <p className="text-xs text-muted-foreground mt-2">
      This action cannot be undone.
    </p>
  </div>
)}

    </div>
  );
};

export default Profile;


LeftSidebar.tsx:
import { Home, Users, UserPlus, FolderKanban, User, Bell, Sparkles, Crown, Search, ChevronLeft, ChevronRight, MessageCircle } from 'lucide-react';
import { UserProfile } from '../services/firestore';
import { cn } from '@/lib/utils';

interface LeftSidebarProps {
  currentPage: string;
  onNavigate: (page: string) => void;
  userProfile?: UserProfile | null;
  collapsed?: boolean;
  onToggleCollapse?: () => void;
}

const LeftSidebar = ({ currentPage, onNavigate, userProfile, collapsed = false, onToggleCollapse }: LeftSidebarProps) => {
  const navItems = [
    { id: 'feed', label: 'Home Feed', icon: Home },
    { id: 'discover', label: 'Discover People', icon: Users },
    { id: 'discover-teams', label: 'Discover Teams', icon: Search },
    { id: 'build', label: 'Build a Team', icon: UserPlus },
    { id: 'teams', label: 'My Teams', icon: FolderKanban },
    { id: 'messages', label: 'Messages', icon: MessageCircle },
    { id: 'notifications', label: 'Notifications', icon: Bell },
    { id: 'profile', label: 'My Profile', icon: User },
  ];

  const displayName = userProfile?.fullName || 'User';
  const displayRole = userProfile?.primaryRole || 'Team Member';
  const displayAvatar = userProfile?.avatar || `https://api.dicebear.com/7.x/initials/svg?seed=${encodeURIComponent(displayName)}`;

  return (
    <aside className={cn(
      "flex-shrink-0 transition-all duration-300 max-h-[calc(100vh-6rem)] overflow-y-auto scrollbar-thin scrollbar-thumb-border scrollbar-track-transparent",
      collapsed ? "w-16" : "w-72"
    )}>
      <div className="space-y-4 pb-4">
        {/* Collapse Toggle Button */}
        {onToggleCollapse && (
          <button
            onClick={onToggleCollapse}
            className={cn(
              "w-full flex items-center justify-center p-4 rounded-lg transition-all duration-200 sticky top-0 z-10",
              "bg-white border border-gray-300 text-gray-700 hover:bg-gray-50",
              "shadow-sm text-2xl font-bold"
            )}
            title={collapsed ? "Expand sidebar" : "Collapse sidebar"}
          >
            {collapsed ? "->" : "<-"}
          </button>
        )}

        {/* Profile Card */}
        <div className="card-base overflow-hidden">
          <div className={cn("bg-gradient-to-r from-primary to-primary/80", collapsed ? "h-8" : "h-16")} />
          <div className={cn("px-4 pb-4", collapsed && "px-2 pb-2")}>
            <div className={cn("-mt-8 flex flex-col items-center", collapsed && "-mt-4")}>
              <img 
                src={
                  userProfile?.avatar
                    ? `${userProfile.avatar}?t=${Date.now()}`
                    : `https://api.dicebear.com/7.x/initials/svg?seed=${encodeURIComponent(
                        userProfile?.fullName || 'User'
                      )}`
                }
                alt={displayName} 
                className={cn(
                  "avatar border-4 border-card transition-all",
                  collapsed ? "w-10 h-10" : "w-16 h-16"
                )} 
              />
              {!collapsed && (
                <>
                  <h3 className="mt-2 font-display font-bold text-foreground">{displayName}</h3>
                  <p className="text-sm text-muted-foreground">{displayRole}</p>
                  {userProfile?.isTeamLeader ? (
                    <div className="mt-3 flex items-center gap-1 px-2 py-0.5 rounded-full text-xs font-medium bg-accent/10 text-accent">
                      <Crown className="w-3 h-3" />
                      <span>Team Leader</span>
                    </div>
                  ) : userProfile?.teamId ? (
                    <div className="mt-3 flex items-center gap-1 px-2 py-0.5 rounded-full text-xs font-medium bg-primary/10 text-primary">
                      <FolderKanban className="w-3 h-3" />
                      <span>In a Team</span>
                    </div>
                  ) : (
                    <div className="mt-3 flex items-center gap-1 ai-badge">
                      <Sparkles className="w-3 h-3" />
                      <span>Available</span>
                    </div>
                  )}
                </>
              )}
            </div>
          </div>
        </div>

        {/* Navigation */}
        <nav className={cn("card-base", collapsed ? "p-1" : "p-2")}>
          {navItems.map((item) => (
            <button
              key={item.id}
              onClick={() => onNavigate(item.id)}
              className={cn(
                "nav-item w-full",
                currentPage === item.id && 'nav-item-active',
                collapsed && 'justify-center px-2'
              )}
              title={collapsed ? item.label : undefined}
            >
              <item.icon className="w-5 h-5 flex-shrink-0" />
              {!collapsed && <span>{item.label}</span>}
            </button>
          ))}
        </nav>

        {/* Quote */}
        {!collapsed && (
          <div className="card-base p-4">
            <p className="text-sm text-muted-foreground italic leading-relaxed">
              "Teams fail because of poor composition, not poor ideas."
            </p>
            <p className="mt-2 text-xs text-primary font-medium">‚Äî TeamUp Philosophy</p>
          </div>
        )}
      </div>
    </aside>
  );
};

export default LeftSidebar;

firestore.ts:
  import { 
    collection, 
    doc, 
    getDoc, 
    getDocs, 
    setDoc, 
    updateDoc, 
    deleteDoc,
    query, 
    where, 
    orderBy,
    addDoc,
    serverTimestamp,
    onSnapshot,
    Unsubscribe,
    limit,
    arrayUnion,
    arrayRemove,
  } from 'firebase/firestore';
  import { supabase } from '@/lib/supabase';
  import { Timestamp } from 'firebase/firestore';
  import { generateUsernameFromName, isValidUsername } from '@/utils/username';
  import { db, isFirebaseConfigured } from '@/lib/firebase';
  import { getHiddenUsers } from './blockReportService';
  import type { 
    UserProfile, 
    Team, 
    TeamMember, 
    Invitation, 
    WorkspaceLog,
    Notification,
    FeedPost,
    TeamTask,
    Message,
    Conversation,
    SkillVerification
  } from '@/types/firestore.types';
  import {
    ref,
    uploadBytes,
    getDownloadURL,
    deleteObject,
  } from 'firebase/storage';
  import { storage } from '@/lib/firebase';
  // Re-export types for convenience
  export type { UserProfile, Team, TeamMember, Invitation, WorkspaceLog, Notification, FeedPost, TeamTask, Message, Conversation, SkillVerification };
  // ========================
  // PROFILE FUNCTIONS
  // ========================
  export const getProfile = async (userId: string): Promise<UserProfile | null> => {
    if (!isFirebaseConfigured()) return null;
    const docRef = doc(db, 'profiles', userId);
    const docSnap = await getDoc(docRef);
    return docSnap.exists() ? { id: docSnap.id, ...docSnap.data() } as UserProfile : null;
  };
  export const createProfile = async (userId: string, data: Partial<UserProfile>): Promise<void> => {
    if (!isFirebaseConfigured()) return;
    await setDoc(doc(db, 'profiles', userId), {
      ...data,
      username: data.username || null,
      teamIds: [],
      leaderOfTeamIds: [],
      createdAt: serverTimestamp()
    });
  };
  
  export const updateProfile = async (
  userId: string,
  data: Partial<UserProfile>
): Promise<void> => {
  if (!isFirebaseConfigured()) return;
  if (!userId) throw new Error('User ID is required for profile update');

  const updateData: any = {
    ...data,
    updatedAt: serverTimestamp()
  };

  if (data.username !== undefined) {
    updateData.username = data.username.toLowerCase();
  }

  await updateDoc(doc(db, 'profiles', userId), updateData);
};
  // ========================
  // SKILL VERIFICATION FUNCTIONS
  // ========================
  export const getSkillVerification = async (userId: string): Promise<SkillVerification | null> => {
    if (!isFirebaseConfigured()) return null;
    
    const q = query(
      collection(db, 'skillVerifications'),
      where('userId', '==', userId),
      where('status', '==', 'verified'),
      orderBy('verifiedAt', 'desc'),
      limit(1)
    );
    
    const snapshot = await getDocs(q);
    if (snapshot.empty) return null;
    
    return { id: snapshot.docs[0].id, ...snapshot.docs[0].data() } as SkillVerification;
  };
  export const createSkillVerification = async (
  userId: string,
  data: Omit<SkillVerification, 'id' | 'userId' | 'verifiedAt'>
): Promise<string> => {
  if (!isFirebaseConfigured()) return '';
  
  // Invalidate any existing verifications
  const existing = await getSkillVerification(userId);
  if (existing) {
    await updateDoc(doc(db, 'skillVerifications', existing.id), {
      status: 'invalidated',
      invalidatedAt: serverTimestamp(),
      invalidationReason: 'manual'
    });
  }
  
  const docRef = await addDoc(collection(db, 'skillVerifications'), {
    ...data,
    userId,
    verifiedAt: serverTimestamp()
  });
  
  return docRef.id;
};
  export const invalidateSkillVerification = async (
    userId: string,
    reason: 'profile_edited' | 'manual' | 'expired'
  ): Promise<void> => {
    if (!isFirebaseConfigured()) return;
    
    const verification = await getSkillVerification(userId);
    if (!verification) return;
    
    await updateDoc(doc(db, 'skillVerifications', verification.id), {
      status: 'invalidated',
      invalidatedAt: serverTimestamp(),
      invalidationReason: reason
    });
  };
  export const subscribeToSkillVerification = (
    userId: string,
    onUpdate: (verification: SkillVerification | null) => void
  ): Unsubscribe => {
    if (!isFirebaseConfigured()) return () => {};
    
    const q = query(
      collection(db, 'skillVerifications'),
      where('userId', '==', userId),
      where('status', '==', 'verified'),
      orderBy('verifiedAt', 'desc'),
      limit(1)
    );
    
    return onSnapshot(q, (snapshot) => {
      if (snapshot.empty) {
        onUpdate(null);
        return;
      }
      onUpdate({ id: snapshot.docs[0].id, ...snapshot.docs[0].data() } as SkillVerification);
    });
  };
  // ========================
  // DISCOVER PEOPLE FUNCTIONS
  // ========================
  export const getAllUsers = async (excludeUserId?: string): Promise<UserProfile[]> => {
    if (!isFirebaseConfigured()) return [];
    const q = query(collection(db, 'profiles'), orderBy('createdAt', 'desc'));
    const snapshot = await getDocs(q);
    return snapshot.docs
      .map(doc => ({ id: doc.id, ...doc.data() } as UserProfile))
      .filter(user => user.id !== excludeUserId);
  };
  // Subscribe to all users in real-time
  export const subscribeToAllUsers = (
    excludeUserId: string,
    onUpdate: (users: UserProfile[]) => void
  ): Unsubscribe => {
    if (!isFirebaseConfigured()) return () => {};
    
    const q = query(collection(db, 'profiles'), orderBy('createdAt', 'desc'));
    
    return onSnapshot(q, (snapshot) => {
      const users = snapshot.docs
        .map(doc => ({ id: doc.id, ...doc.data() } as UserProfile))
        .filter(user => user.id !== excludeUserId);
      onUpdate(users);
    });
  };
  export const getAvailableUsers = async (excludeUserId?: string): Promise<UserProfile[]> => {
    if (!isFirebaseConfigured()) return [];
    // Return all users since users can join multiple teams now
    const q = query(collection(db, 'profiles'), orderBy('createdAt', 'desc'));
    const snapshot = await getDocs(q);
    return snapshot.docs
      .map(doc => ({ id: doc.id, ...doc.data() } as UserProfile))
      .filter(user => user.id !== excludeUserId);
  };
  export const getAvailableUsersByRole = async (role: string, excludeUserId?: string): Promise<UserProfile[]> => {
    if (!isFirebaseConfigured()) return [];
    const q = query(
      collection(db, 'profiles'),
      where('primaryRole', '==', role)
    );
    const snapshot = await getDocs(q);
    return snapshot.docs
      .map(doc => ({ id: doc.id, ...doc.data() } as UserProfile))
      .filter(user => user.id !== excludeUserId);
  };
  export const getAvailableRoles = async (): Promise<string[]> => {
    if (!isFirebaseConfigured()) return [];
    const snapshot = await getDocs(collection(db, 'profiles'));
    const roles = new Set<string>();
    snapshot.docs.forEach(doc => {
      const data = doc.data();
      if (data.primaryRole) roles.add(data.primaryRole);
    });
    return Array.from(roles);
  };
  // ========================
  // TEAM FUNCTIONS
  // ========================
  export const createTeam = async (data: Omit<Team, 'id' | 'createdAt' | 'members'>): Promise<string> => {
    if (!isFirebaseConfigured()) return '';
    
    const leaderProfile = await getProfile(data.leaderId);
    const leaderName = leaderProfile?.fullName || 'User';
    
    const docRef = await addDoc(collection(db, 'teams'), {
      ...data,
      leaderName,
      members: [{ userId: data.leaderId, role: 'Team Leader', userName: leaderName }],
      createdAt: serverTimestamp()
    });
    
    // Update user's teamIds and leaderOfTeamIds arrays
    await updateDoc(doc(db, 'profiles', data.leaderId), {
      teamIds: arrayUnion(docRef.id),
      leaderOfTeamIds: arrayUnion(docRef.id)
    });
    
    // Create feed post for team creation
    await createFeedPost({
      authorId: data.leaderId,
      authorName: leaderName,
      authorAvatar: leaderProfile?.avatar,
      authorRole: leaderProfile?.primaryRole,
      type: 'team_created',
      title: `üöÄ Created team: ${data.name}`,
      description: data.description,
      teamId: docRef.id,
      teamName: data.name,
      rolesNeeded: data.rolesNeeded
    });
    
    return docRef.id;
  };
  export const getTeam = async (teamId: string): Promise<Team | null> => {
    if (!isFirebaseConfigured()) return null;
    const docSnap = await getDoc(doc(db, 'teams', teamId));
    return docSnap.exists() ? { id: docSnap.id, ...docSnap.data() } as Team : null;
  };
  export const getUserTeams = async (userId: string): Promise<Team[]> => {
    if (!isFirebaseConfigured()) return [];
    
    // Get user's profile to check teamIds array
    const profile = await getProfile(userId);
    if (!profile?.teamIds || profile.teamIds.length === 0) return [];
    
    // Fetch all teams the user is part of
    const teams = await Promise.all(
      profile.teamIds.map(async (teamId: string) => await getTeam(teamId))
    );
    
    return teams.filter(team => team !== null) as Team[];
  };
  export const subscribeToUserTeams = (
    userId: string,
    onUpdate: (teams: Team[]) => void
  ): Unsubscribe => {
    if (!isFirebaseConfigured()) return () => {};
    
    // Subscribe to user's profile to get teamIds
    const profileRef = doc(db, 'profiles', userId);
    
    return onSnapshot(profileRef, async (profileSnap) => {
      const profile = profileSnap.exists() ? profileSnap.data() as UserProfile : null;
      if (!profile?.teamIds || profile.teamIds.length === 0) {
        onUpdate([]);
        return;
      }
      
      // Fetch all teams
      const teams = await Promise.all(
        profile.teamIds.map(async (teamId: string) => await getTeam(teamId))
      );
      
      onUpdate(teams.filter(team => team !== null) as Team[]);
    });
  };
  export const updateTeam = async (teamId: string, data: Partial<Team>): Promise<void> => {
    if (!isFirebaseConfigured()) return;
    await updateDoc(doc(db, 'teams', teamId), data);
  };
  // ========================
  // TEAM MEMBER FUNCTIONS
  // ========================
  export const addTeamMember = async (teamId: string, userId: string, role: string): Promise<void> => {
    if (!isFirebaseConfigured()) return;
    
    // Get current team
    const team = await getTeam(teamId);
    if (!team) throw new Error('Team not found');
    
    // Check if team is full
    if (team.members.length >= team.maxMembers) {
      throw new Error('Team is full');
    }
    
    // Check if user is already in this team
    if (team.members.some(m => m.userId === userId)) {
      throw new Error('User is already in this team');
    }
    
    const profile = await getProfile(userId);
    const userName = profile?.fullName || 'User';
    
    // Add member to team's members array
    const updatedMembers = [...(team.members || []), { userId, role, userName }];
    await updateTeam(teamId, { members: updatedMembers });
    
    // Update user's teamIds array
    await updateDoc(doc(db, 'profiles', userId), {
      teamIds: arrayUnion(teamId)
    });
    
    // Create feed post
    await createFeedPost({
      authorId: userId,
      authorName: userName,
      authorAvatar: profile?.avatar,
      authorRole: profile?.primaryRole,
      type: 'member_joined',
      title: `üéâ Joined team: ${team.name}`,
      description: `${userName} joined as ${role}`,
      teamId,
      teamName: team.name
    });
    
    // Also add to teamMembers collection for backward compatibility
    await addDoc(collection(db, 'teamMembers'), {
      teamId,
      userId,
      role,
      joinedAt: serverTimestamp()
    });
  };
  export const getTeamMembers = async (teamId: string): Promise<(TeamMember & { profile: UserProfile | null })[]> => {
    if (!isFirebaseConfigured()) return [];
    
    // Get team and its members array
    const team = await getTeam(teamId);
    if (!team) return [];
    
    // Fetch profiles for each member
    const members = await Promise.all(
      (team.members || []).map(async (member) => {
        const profile = await getProfile(member.userId);
        return {
          id: `${teamId}-${member.userId}`,
          teamId,
          userId: member.userId,
          role: member.role,
          joinedAt: team.createdAt,
          profile
        } as TeamMember & { profile: UserProfile | null };
      })
    );
    
    return members;
  };
  export const subscribeToTeamMembers = (
    teamId: string,
    onUpdate: (members: (TeamMember & { profile: UserProfile | null })[]) => void
  ): Unsubscribe => {
    if (!isFirebaseConfigured()) return () => {};
    
    const teamRef = doc(db, 'teams', teamId);
    
    return onSnapshot(teamRef, async (teamSnap) => {
      if (!teamSnap.exists()) {
        onUpdate([]);
        return;
      }
      
      const team = { id: teamSnap.id, ...teamSnap.data() } as Team;
      
      const members = await Promise.all(
        (team.members || []).map(async (member) => {
          const profile = await getProfile(member.userId);
          return {
            id: `${teamId}-${member.userId}`,
            teamId,
            userId: member.userId,
            role: member.role,
            joinedAt: team.createdAt,
            profile
          } as TeamMember & { profile: UserProfile | null };
        })
      );
      
      onUpdate(members);
    });
  };
  export const removeTeamMember = async (
  teamId: string,
  userId: string,
  profile?: { fullName?: string; avatar?: string }
) => {
  const teamRef = doc(db, 'teams', teamId);
  const snap = await getDoc(teamRef);
  if (!snap.exists()) {
    throw new Error('Team not found');
  }
  const teamData = snap.data();
  
  // Get user profile if not provided
  let userProfile = profile;
  if (!userProfile) {
    const prof = await getProfile(userId);
    userProfile = {
      fullName: prof?.fullName,
      avatar: prof?.avatar
    };
  }
  
  // ‚úÖ REMOVE MEMBER FROM TEAM
  const updatedMembers = teamData.members.filter(
    (m: any) => m.userId !== userId
  );
  
  // ‚úÖ ADD TO recentlyLeft
  const recentlyLeft = teamData.recentlyLeft || [];
  const updatedRecentlyLeft = [
    ...recentlyLeft,
    {
      userId,
      name: userProfile?.fullName || 'Unknown',
      avatar: userProfile?.avatar || null,
      leftAt: Timestamp.now(),
    },
  ].slice(-5);
  
  // ‚úÖ UPDATE TEAM DOCUMENT
  await updateDoc(teamRef, {
    members: updatedMembers,
    memberIds: updatedMembers.map((m: any) => m.userId),
    recentlyLeft: updatedRecentlyLeft,
  });
  
  // ‚úÖ REMOVE TEAM FROM USER'S PROFILE (THIS WAS MISSING!)
  await updateDoc(doc(db, 'profiles', userId), {
    teamIds: arrayRemove(teamId),
    leaderOfTeamIds: arrayRemove(teamId)
  });
};

  // Terminate team (leader only)
  export const terminateTeam = async (
    teamId: string,
    leaderId: string
  ): Promise<void> => {
    if (!isFirebaseConfigured()) return;
    const team = await getTeam(teamId);
    if (!team) return;
    if (team.leaderId !== leaderId) {
      throw new Error('Only team leader can terminate the team');
    }
    
    // 1Ô∏è‚É£ Remove team from all member profiles (using arrayRemove for instant UI update)
    await Promise.allSettled(
      team.members.map(async (member) => {
        const profileRef = doc(db, 'profiles', member.userId);
        await updateDoc(profileRef, {
          teamIds: arrayRemove(teamId),
          leaderOfTeamIds: arrayRemove(teamId)
        });
      })
    );
    
    // 2Ô∏è‚É£ Delete teamMembers (BEST EFFORT)
    try {
      const membersQuery = query(
        collection(db, 'teamMembers'),
        where('teamId', '==', teamId)
      );
      const snapshot = await getDocs(membersQuery);
      await Promise.all(snapshot.docs.map(d => deleteDoc(d.ref)));
    } catch (err) {
      console.warn('[terminateTeam] teamMembers cleanup skipped');
    }
    
    // 3Ô∏è‚É£ Delete invitations (BEST EFFORT)
    try {
      const invitationsQuery = query(
        collection(db, 'invitations'),
        where('teamId', '==', teamId)
      );
      const snapshot = await getDocs(invitationsQuery);
      await Promise.all(snapshot.docs.map(d => deleteDoc(d.ref)));
    } catch (err) {
      console.warn('[terminateTeam] invitations cleanup skipped');
    }
    
    // 4Ô∏è‚É£ Delete team tasks (BEST EFFORT)
    try {
      const tasksQuery = query(
        collection(db, 'teamTasks'),
        where('teamId', '==', teamId)
      );
      const snapshot = await getDocs(tasksQuery);
      await Promise.all(snapshot.docs.map(d => deleteDoc(d.ref)));
    } catch (err) {
      console.warn('[terminateTeam] tasks cleanup skipped');
    }
    
    // 5Ô∏è‚É£ Delete workspace logs (BEST EFFORT)
    try {
      const logsQuery = query(
        collection(db, 'workspaceLogs'),
        where('teamId', '==', teamId)
      );
      const snapshot = await getDocs(logsQuery);
      await Promise.all(snapshot.docs.map(d => deleteDoc(d.ref)));
    } catch (err) {
      console.warn('[terminateTeam] workspace logs cleanup skipped');
    }
    
    // 6Ô∏è‚É£ DELETE TEAM (SOURCE OF TRUTH)
    await deleteDoc(doc(db, 'teams', teamId));
  };
  export const subscribeToAvailableTeams = (
    onUpdate: (teams: Team[]) => void,
    currentUserId?: string
  ): Unsubscribe => {
    if (!isFirebaseConfigured()) return () => {};
    
    const q = query(
      collection(db, 'teams'),
      where('status', '==', 'forming'),
      orderBy('createdAt', 'desc')
    );
    
    return onSnapshot(q, async (snapshot) => {
      let teams = snapshot.docs
        .map(doc => ({ id: doc.id, ...doc.data() } as Team))
        .filter(team => team.members.length < team.maxMembers);
      
      if (currentUserId) {
        const hiddenUsers = await getHiddenUsers(currentUserId);
        teams = teams.filter(team => !hiddenUsers.has(team.leaderId));
      }
      
      onUpdate(teams);
    }, (error) => {
      console.error('Available teams subscription error:', error);
      onUpdate([]);
    });
  };
  // ========================
  // INVITATION FUNCTIONS
  // ========================
  export const sendInvitation = async (data: Omit<Invitation, 'id' | 'status' | 'createdAt'>): Promise<void> => {
    if (!isFirebaseConfigured()) return;
    
    const isJoinRequest = data.type === 'join_request';
    
    // Check if team still has room
    const team = await getTeam(data.teamId);
    if (!team) {
      throw new Error('Team not found');
    }
    if (team.members.length >= team.maxMembers) {
      throw new Error('Team is full');
    }
    
    // Check if user is already in this team
    if (team.members.some(m => m.userId === (isJoinRequest ? data.fromUserId : data.toUserId))) {
      throw new Error('User is already in this team');
    }
    
    // Check for existing pending invitation/request
    const existingQuery = query(
      collection(db, 'invitations'),
      where('fromUserId', '==', data.fromUserId),
      where('teamId', '==', data.teamId),
      where('status', '==', 'pending')
    );
    const existingSnap = await getDocs(existingQuery);
    if (!existingSnap.empty) {
      throw new Error(isJoinRequest ? 'Join request already sent' : 'Invitation already sent');
    }
    
    // Create invitation/join request
    await addDoc(collection(db, 'invitations'), {
      ...data,
      teamDescription: team.description,
      status: 'pending',
      createdAt: serverTimestamp()
    });
    
    // Create notification
    const notifyUserId = isJoinRequest ? data.toUserId : data.toUserId;
    await createNotification({
      toUserId: notifyUserId,
      fromUserId: data.fromUserId,
      fromUserName: data.fromUserName,
      type: isJoinRequest ? 'JOIN_REQUEST' : 'INVITE',
      teamId: data.teamId,
      teamName: data.teamName,
      message: data.message
    });
  };
  export const getIncomingInvitations = async (userId: string): Promise<Invitation[]> => {
    if (!isFirebaseConfigured()) return [];
    const q = query(
      collection(db, 'invitations'),
      where('toUserId', '==', userId),
      where('status', '==', 'pending')
    );
    const snapshot = await getDocs(q);
    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Invitation));
  };
  export const getOutgoingInvitations = async (userId: string): Promise<Invitation[]> => {
    if (!isFirebaseConfigured()) return [];
    const q = query(
      collection(db, 'invitations'),
      where('fromUserId', '==', userId)
    );
    const snapshot = await getDocs(q);
    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Invitation));
  };
  export const respondToInvitation = async (
    invitationId: string, 
    status: 'accepted' | 'rejected',
    teamId?: string,
    userId?: string,
    role?: string
  ): Promise<void> => {
    if (!isFirebaseConfigured()) return;
    
    // Get invitation details
    const invRef = doc(db, 'invitations', invitationId);
    const invSnap = await getDoc(invRef);
    const invitation = invSnap.exists() ? { id: invSnap.id, ...invSnap.data() } as Invitation : null;
    
    if (!invitation) {
      throw new Error('Invitation not found');
    }
    
    const isJoinRequest = invitation.type === 'join_request';
    
    // Determine who is joining
    const joiningUserId = isJoinRequest ? invitation.fromUserId : invitation.toUserId;
    const joiningUserName = isJoinRequest ? invitation.fromUserName : invitation.toUserName;
    
    // If accepting, verify the team still has room
    if (status === 'accepted') {
      const team = await getTeam(invitation.teamId);
      if (!team) {
        throw new Error('Team no longer exists');
      }
      if (team.members.length >= team.maxMembers) {
        throw new Error('Team is full');
      }
      
      // Check if user is already in this team
      if (team.members.some(m => m.userId === joiningUserId)) {
        throw new Error('User is already in this team');
      }
    }
    
    await updateDoc(invRef, { status });
    
    if (status === 'accepted') {
      const joiningProfile = await getProfile(joiningUserId);
      const joiningRole = joiningProfile?.primaryRole || role || 'Member';
      
      await addTeamMember(invitation.teamId, joiningUserId, joiningRole);
      
      // Notify the appropriate party
      const notifyUserId = isJoinRequest ? invitation.fromUserId : invitation.fromUserId;
      const responderProfile = await getProfile(isJoinRequest ? invitation.toUserId : invitation.toUserId);
      
      await createNotification({
        toUserId: notifyUserId,
        fromUserId: isJoinRequest ? invitation.toUserId : invitation.toUserId,
        fromUserName: responderProfile?.fullName || 'User',
        type: 'ACCEPTED',
        teamId: invitation.teamId,
        teamName: invitation.teamName,
        message: isJoinRequest 
          ? `Your request to join ${invitation.teamName} was accepted!`
          : `${joiningUserName} accepted your invitation to join ${invitation.teamName}`
      });
    } else if (status === 'rejected') {
      const notifyUserId = isJoinRequest ? invitation.fromUserId : invitation.fromUserId;
      const responderProfile = await getProfile(isJoinRequest ? invitation.toUserId : invitation.toUserId);
      
      await createNotification({
        toUserId: notifyUserId,
        fromUserId: isJoinRequest ? invitation.toUserId : invitation.toUserId,
        fromUserName: responderProfile?.fullName || 'User',
        type: 'REJECTED',
        teamId: invitation.teamId,
        teamName: invitation.teamName,
        message: isJoinRequest 
          ? `Your request to join ${invitation.teamName} was declined`
          : `${invitation.toUserName} declined your invitation to join ${invitation.teamName}`
      });
    }
  };
  export const subscribeToJoinRequests = (
    teamId: string,
    onUpdate: (requests: Invitation[]) => void
  ): Unsubscribe => {
    if (!isFirebaseConfigured()) return () => {};
    
    const q = query(
      collection(db, 'invitations'),
      where('teamId', '==', teamId),
      where('type', '==', 'join_request'),
      where('status', '==', 'pending')
    );
    
    return onSnapshot(q, (snapshot) => {
      const requests = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Invitation));
      onUpdate(requests);
    }, (error) => {
      console.error('Join requests subscription error:', error);
      onUpdate([]);
    });
  };
  export const subscribeToInvitations = (
    userId: string,
    onUpdate: (incoming: Invitation[], outgoing: Invitation[]) => void
  ): Unsubscribe => {
    if (!isFirebaseConfigured()) return () => {};
    
    const incomingQuery = query(
      collection(db, 'invitations'),
      where('toUserId', '==', userId),
      where('status', '==', 'pending')
    );
    
    const outgoingQuery = query(
      collection(db, 'invitations'),
      where('fromUserId', '==', userId)
    );
    
    let incoming: Invitation[] = [];
    let outgoing: Invitation[] = [];
    
    const unsubIncoming = onSnapshot(incomingQuery, (snapshot) => {
      incoming = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Invitation));
      onUpdate(incoming, outgoing);
    });
    
    const unsubOutgoing = onSnapshot(outgoingQuery, (snapshot) => {
      outgoing = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Invitation));
      onUpdate(incoming, outgoing);
    });
    
    return () => {
      unsubIncoming();
      unsubOutgoing();
    };
  };
  // ========================
  // NOTIFICATION FUNCTIONS
  // ========================
  export const createNotification = async (data: Omit<Notification, 'id' | 'read' | 'createdAt'>): Promise<void> => {
    if (!isFirebaseConfigured()) return;
    await addDoc(collection(db, 'notifications'), {
      ...data,
      read: false,
      createdAt: serverTimestamp()
    });
  };
  export const getAvailableCities = async (): Promise<string[]> => {
    if (!isFirebaseConfigured()) return [];
    const snapshot = await getDocs(collection(db, 'profiles'));
    const cityMap = new Map<string, string>();
    snapshot.forEach(doc => {
      const city = doc.data().city;
      if (city && typeof city === 'string') {
        const normalized = city.trim().toLowerCase();
        // preserve first-seen casing
        if (!cityMap.has(normalized)) {
          cityMap.set(normalized, city.trim());
        }
      }
    });
    return Array.from(cityMap.values()).sort((a, b) =>
      a.localeCompare(b)
    );
  };

  export const getAvailableTeamCities = async (): Promise<string[]> => {
  if (!isFirebaseConfigured()) return [];
  const snapshot = await getDocs(collection(db, 'teams'));
  const cityMap = new Map<string, string>();
  snapshot.forEach(doc => {
    const city = doc.data().city;
    if (city && typeof city === 'string') {
      const normalized = city.trim().toLowerCase();
      // preserve first-seen casing
      if (!cityMap.has(normalized)) {
        cityMap.set(normalized, city.trim());
      }
    }
  });
  return Array.from(cityMap.values()).sort((a, b) =>
    a.localeCompare(b)
  );
};

  export const getNotifications = async (userId: string): Promise<Notification[]> => {
    if (!isFirebaseConfigured()) return [];
    const q = query(
      collection(db, 'notifications'),
      where('toUserId', '==', userId),
      orderBy('createdAt', 'desc'),
      limit(50)
    );
    const snapshot = await getDocs(q);
    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Notification));
  };
  export const subscribeToNotifications = (
    userId: string,
    onUpdate: (notifications: Notification[]) => void
  ): Unsubscribe => {
    if (!isFirebaseConfigured()) return () => {};
    
    const q = query(
      collection(db, 'notifications'),
      where('toUserId', '==', userId),
      orderBy('createdAt', 'desc'),
      limit(50)
    );
    
    return onSnapshot(q, (snapshot) => {
      const notifications = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Notification));
      onUpdate(notifications);
    });
  };
  export const markNotificationAsRead = async (notificationId: string): Promise<void> => {
    if (!isFirebaseConfigured()) return;
    await updateDoc(doc(db, 'notifications', notificationId), { read: true });
  };
  export const markAllNotificationsAsRead = async (userId: string): Promise<void> => {
    if (!isFirebaseConfigured()) return;
    const q = query(
      collection(db, 'notifications'),
      where('toUserId', '==', userId),
      where('read', '==', false)
    );
    const snapshot = await getDocs(q);
    await Promise.all(snapshot.docs.map(d => updateDoc(d.ref, { read: true })));
  };
  export const getUnreadNotificationCount = async (userId: string): Promise<number> => {
    if (!isFirebaseConfigured()) return 0;
    const q = query(
      collection(db, 'notifications'),
      where('toUserId', '==', userId),
      where('read', '==', false)
    );
    const snapshot = await getDocs(q);
    return snapshot.size;
  };
  // ========================
  // FEED POST FUNCTIONS
  // ========================
  export const createFeedPost = async (data: Omit<FeedPost, 'id' | 'createdAt'>): Promise<string> => {
    if (!isFirebaseConfigured()) return '';
    const docRef = await addDoc(collection(db, 'posts'), {
      ...data,
      createdAt: serverTimestamp()
    });
    return docRef.id;
  };
  export const createUserPost = async (
    userId: string,
    data: {
      title: string;
      description: string;
      tags?: string[];
      image?: File | null;
    }
  ): Promise<string> => {
    if (!isFirebaseConfigured()) return "";

    const profile = await getProfile(userId);

    let imageUrl: string | null = null;

    // ‚úÖ STEP 1: Upload image to Supabase (if exists)
    if (data.image) {
      try {
        const fileExt = data.image.name.split(".").pop() || "jpg";
        const fileName = `${Date.now()}-${Math.random().toString(36).slice(2)}.${fileExt}`;
        const filePath = `${userId}/${fileName}`;

        // ‚úÖ Optional: timeout protection (keeps your UI from hanging)
        const uploadWithTimeout = Promise.race([
          supabase.storage
            .from("post-images") // ‚úÖ bucket id
            .upload(filePath, data.image, {
              contentType: data.image.type || "image/jpeg",
              upsert: false,
            }),
          new Promise((_, reject) =>
            setTimeout(() => reject(new Error("Image upload timed out. Please try again.")), 20000)
          ),
        ]) as Promise<{ data: any; error: any }>;

        const { error: uploadError } = await uploadWithTimeout;

        if (uploadError) {
          throw new Error(uploadError.message);
        }

        const { data: publicData } = supabase.storage
          .from("post-images") // ‚úÖ bucket id
          .getPublicUrl(filePath);

        imageUrl = publicData.publicUrl;
      } catch (err: any) {
        console.error("Supabase image upload failed:", err);
        throw new Error(err?.message || "Image upload failed. Please try again.");
      }
    }

    // ‚úÖ STEP 2: Save Firestore document
    const docRef = await addDoc(collection(db, "posts"), {
      authorId: userId,
      authorName: profile?.fullName || "User",
      authorAvatar: profile?.avatar,
      authorRole: profile?.primaryRole,
      type: "user_post",
      title: data.title,
      description: data.description,
      tags: data.tags || [],
      imageUrl, // ‚úÖ Supabase public URL
      createdAt: serverTimestamp(),
    });

    return docRef.id;
  };
  export const updatePost = async (
    postId: string,
    userId: string,
    data: {
      title: string;
      description: string;
      tags?: string[];
      image?: File | null;
      removeImage?: boolean;
    }
  ): Promise<void> => {
    if (!isFirebaseConfigured()) return;

    const updateData: any = {
      title: data.title,
      description: data.description,
      tags: data.tags || [],
      updatedAt: serverTimestamp(),
    };

    // ‚úÖ Remove existing image
    if (data.removeImage) {
      updateData.imageUrl = null;
    }

    // ‚úÖ Replace / add new image
    if (data.image) {
      const fileExt = data.image.name.split(".").pop() || "jpg";
      const fileName = `${Date.now()}-${Math.random().toString(36).slice(2)}.${fileExt}`;
      const filePath = `${userId}/${fileName}`;

      const { error: uploadError } = await supabase.storage
        .from("post-images") // üëà bucket id (case-sensitive)
        .upload(filePath, data.image, {
          contentType: data.image.type || "image/jpeg",
          upsert: false,
        });

      if (uploadError) {
        throw new Error(uploadError.message);
      }

      const { data: publicData } = supabase.storage
        .from("post-images")
        .getPublicUrl(filePath);

      updateData.imageUrl = publicData.publicUrl;
    }

    await updateDoc(doc(db, "posts", postId), updateData);
  };
  export const deletePost = async (postId: string): Promise<void> => {
    if (!isFirebaseConfigured()) return;
    await deleteDoc(doc(db, 'posts', postId));
  };
  export const getUserPosts = async (userId: string): Promise<FeedPost[]> => {
    if (!isFirebaseConfigured()) return [];
    const q = query(
      collection(db, 'posts'),
      where('authorId', '==', userId),
      orderBy('createdAt', 'desc')
    );
    const snapshot = await getDocs(q);
    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as FeedPost));
  };
  export const subscribeToUserPosts = (
    userId: string,
    onUpdate: (posts: FeedPost[]) => void
  ): Unsubscribe => {
    if (!isFirebaseConfigured()) return () => {};
    
    const q = query(
      collection(db, 'posts'),
      where('authorId', '==', userId),
      orderBy('createdAt', 'desc')
    );
    
    return onSnapshot(q, (snapshot) => {
      const posts = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as FeedPost));
      onUpdate(posts);
    });
  };
  export const getFeedPosts = async (): Promise<FeedPost[]> => {
    if (!isFirebaseConfigured()) return [];
    const q = query(
      collection(db, 'posts'),
      orderBy('createdAt', 'desc'),
      limit(50)
    );
    const snapshot = await getDocs(q);
    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as FeedPost));
  };
  export const subscribeToFeedPosts = (
    onUpdate: (posts: FeedPost[]) => void,
    currentUserId?: string
  ): Unsubscribe => {
    if (!isFirebaseConfigured()) return () => {};
    
    const q = query(
      collection(db, 'posts'),
      orderBy('createdAt', 'desc'),
      limit(50)
    );
    
    return onSnapshot(q, async (snapshot) => {
      let posts = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as FeedPost));
      
      if (currentUserId) {
        try {
          const hiddenUsers = await getHiddenUsers(currentUserId);
          posts = posts.filter(post => !hiddenUsers.has(post.authorId));
        } catch (error) {
          console.error('Error fetching hidden users:', error);
        }
      }
      
      onUpdate(posts);
    }, (error) => {
      console.error('Feed subscription error:', error);
      onUpdate([]);
    });
  };
  // ========================
  // WORKSPACE LOG FUNCTIONS
  // ========================
  export const addWorkspaceLog = async (teamId: string, userId: string, userName: string, message: string): Promise<void> => {
    if (!isFirebaseConfigured()) return;
    await addDoc(collection(db, 'workspaceLogs'), {
      teamId,
      userId,
      userName,
      message,
      createdAt: serverTimestamp()
    });
  };
  export const getWorkspaceLogs = async (teamId: string): Promise<WorkspaceLog[]> => {
    if (!isFirebaseConfigured()) return [];
    const q = query(
      collection(db, 'workspaceLogs'),
      where('teamId', '==', teamId),
      orderBy('createdAt', 'desc')
    );
    const snapshot = await getDocs(q);
    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as WorkspaceLog));
  };
  export const subscribeToWorkspaceLogs = (
    teamId: string,
    onUpdate: (logs: WorkspaceLog[]) => void
  ): Unsubscribe => {
    if (!isFirebaseConfigured()) return () => {};
    
    const q = query(
      collection(db, 'workspaceLogs'),
      where('teamId', '==', teamId),
      orderBy('createdAt', 'desc')
    );
    
    return onSnapshot(q, (snapshot) => {
      const logs = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as WorkspaceLog));
      onUpdate(logs);
    });
  };
  // ========================
  // TEAM TASK FUNCTIONS
  // ========================
  export const createTeamTask = async (
    teamId: string, 
    data: { title: string; assignedTo: string[]; completed: boolean }
  ): Promise<string> => {
    if (!isFirebaseConfigured()) return '';
    const docRef = await addDoc(collection(db, 'teamTasks'), {
      teamId,
      ...data,
      createdAt: serverTimestamp()
    });
    return docRef.id;
  };
  export const getTeamTasks = async (teamId: string): Promise<TeamTask[]> => {
    if (!isFirebaseConfigured()) return [];
    const q = query(
      collection(db, 'teamTasks'),
      where('teamId', '==', teamId),
      orderBy('createdAt', 'desc')
    );
    const snapshot = await getDocs(q);
    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as TeamTask));
  };
  export const updateTeamTask = async (
    taskId: string,
    data: Partial<Pick<TeamTask, 'title' | 'assignedTo'>>
  ): Promise<void> => {
    if (!isFirebaseConfigured()) return;
    await updateDoc(doc(db, 'teamTasks', taskId), data);
  };
  export const subscribeToTeamTasks = (
    teamId: string,
    onUpdate: (tasks: TeamTask[]) => void
  ) => {
    const q = query(
      collection(db, 'teamTasks'),
      where('teamId', '==', teamId)
    );
    return onSnapshot(q, (snapshot) => {
      const tasks = snapshot.docs.map(doc => ({
        id: doc.id,
        ...(doc.data() as TeamTask),
      }));
      onUpdate(tasks);
    }, (error) => {
      console.error('Team tasks subscription error:', error);
      onUpdate([]);
    });
  };
  export const updateTaskCompletion = async (
    taskId: string, 
    completed: boolean, 
    completedBy: string
  ): Promise<void> => {
    if (!isFirebaseConfigured()) return;
    await updateDoc(doc(db, 'teamTasks', taskId), { 
      completed, 
      completedBy: completed ? completedBy : null,
      completedAt: completed ? serverTimestamp() : null
    });
  };
  export const deleteTeamTask = async (taskId: string): Promise<void> => {
    if (!isFirebaseConfigured()) return;
    await deleteDoc(doc(db, 'teamTasks', taskId));
  };
  // ========================
  // STATS FUNCTIONS
  // ========================
  export const getAvailableUsersCount = async (): Promise<number> => {
    if (!isFirebaseConfigured()) return 0;
    const snapshot = await getDocs(collection(db, 'profiles'));
    return snapshot.size;
  };
  export const getAvailableTeamsCount = async (): Promise<number> => {
    if (!isFirebaseConfigured()) return 0;
    const q = query(collection(db, 'teams'), where('status', '==', 'forming'));
    const snapshot = await getDocs(q);
    return snapshot.size;
  };
  // ========================
  // MESSAGING FUNCTIONS
  // ========================
  export const getOrCreateConversation = async (
    user1Id: string,
    user2Id: string
  ): Promise<string> => {
    if (!isFirebaseConfigured()) return '';
    
    const q = query(
      collection(db, 'conversations'),
      where('participants', 'array-contains', user1Id)
    );
    
    const snapshot = await getDocs(q);
    const existing = snapshot.docs.find(doc => {
      const data = doc.data();
      return data.participants.includes(user2Id);
    });
    
    if (existing) {
      return existing.id;
    }
    
    const [profile1, profile2] = await Promise.all([
      getProfile(user1Id),
      getProfile(user2Id)
    ]);
    
    const docRef = await addDoc(collection(db, 'conversations'), {
      participants: [user1Id, user2Id],
      participantNames: {
        [user1Id]: profile1?.fullName || 'User',
        [user2Id]: profile2?.fullName || 'User'
      },
      participantAvatars: {
        [user1Id]: profile1?.avatar || `https://api.dicebear.com/7.x/initials/svg?seed=${profile1?.fullName || 'User'}`,
        [user2Id]: profile2?.avatar || `https://api.dicebear.com/7.x/initials/svg?seed=${profile2?.fullName || 'User'}`
      },
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    });
    
    return docRef.id;
  };
  export const sendMessage = async (
    conversationId: string,
    senderId: string,
    text: string
  ): Promise<string> => {
    if (!isFirebaseConfigured()) return '';
    const senderProfile = await getProfile(senderId);
    const convSnap = await getDoc(doc(db, 'conversations', conversationId));
    if (!convSnap.exists()) {
      throw new Error('Conversation not found');
    }
    const conversationData = convSnap.data();
    const { participants } = conversationData;
    
    const messageRef = await addDoc(collection(db, 'messages'), {
      conversationId,
      participants,
      senderId,
      senderName: senderProfile?.fullName || 'User',
      text,
      read: false,
      createdAt: serverTimestamp()
    });
    
    await updateDoc(doc(db, 'conversations', conversationId), {
      lastMessage: {
        text,
        senderId,
        sentAt: serverTimestamp()
      },
      updatedAt: serverTimestamp()
    });
    
    const recipientId = participants.find((id: string) => id !== senderId);
    
    if (recipientId) {
      await createNotification({
        toUserId: recipientId,
        fromUserId: senderId,
        fromUserName: senderProfile?.fullName || 'User',
        type: 'MESSAGE',
        message: text.length > 50 ? text.substring(0, 50) + '...' : text,
        conversationId
      });
    }
    
    return messageRef.id;
  };

  export const subscribeToProfile = (
  userId: string,
  onUpdate: (profile: UserProfile | null) => void
) => {
  if (!isFirebaseConfigured()) return () => {};

  const ref = doc(db, 'profiles', userId);

  return onSnapshot(ref, (snap) => {
    if (!snap.exists()) {
      onUpdate(null);
      return;
    }
    onUpdate({ id: snap.id, ...snap.data() } as UserProfile);
  });
};

  export const uploadProfilePicture = async (
  userId: string,
  file: File
) => {
  // ‚úÖ CORRECT PATH (NO DOUBLE avatars)
  const filePath = userId;

  const { error } = await supabase.storage
    .from('avatars')
    .upload(filePath, file, { upsert: true });

  if (error) {
    console.error('Supabase upload error:', error);
    throw error;
  }

  const { data } = supabase.storage
    .from('avatars')
    .getPublicUrl(filePath);

  // ‚úÖ SAVE URL TO FIRESTORE (SOURCE OF TRUTH)
  await updateDoc(doc(db, 'profiles', userId), {
    avatar: data.publicUrl,
    updatedAt: serverTimestamp()
  });

  return data.publicUrl;
};

  export const deleteUserCompletely = async (userId: string) => {
    // 1. Get profile
    const profileRef = doc(db, 'profiles', userId);
    const profileSnap = await getDocs(query(collection(db, 'profiles'), where('__name__', '==', userId)));
    const profile = profileSnap.docs[0]?.data();
    if (!profile) return;
    // 2. Handle team
    if (profile.teamId) {
      const teamRef = doc(db, 'teams', profile.teamId);
      const teamSnap = await getDocs(query(collection(db, 'teams'), where('__name__', '==', profile.teamId)));
      const team = teamSnap.docs[0]?.data();
      if (team?.leaderId === userId) {
        // Delete team
        await deleteDoc(teamRef);
      } else {
        // Remove member
        const updatedMembers = team.members.filter((m: any) => m.userId !== userId);
        await updateDoc(teamRef, { members: updatedMembers });
      }
    }
    // 3. Delete user's posts
    const postsSnap = await getDocs(
      query(collection(db, 'posts'), where('authorId', '==', userId))
    );
    for (const docu of postsSnap.docs) {
      await deleteDoc(docu.ref);
    }
    // 4. Delete profile
    await deleteDoc(profileRef);
  };
  export const subscribeToConversations = (
    userId: string,
    onUpdate: (conversations: Conversation[]) => void
  ): Unsubscribe => {
    if (!isFirebaseConfigured()) return () => {};
    
    const q = query(
      collection(db, 'conversations'),
      where('participants', 'array-contains', userId),
      orderBy('updatedAt', 'desc')
    );
    
    return onSnapshot(q, (snapshot) => {
      const conversations = snapshot.docs.map(doc => ({ 
        id: doc.id, 
        ...doc.data() 
      } as Conversation));
      onUpdate(conversations);
    }, (error) => {
      console.error('Conversations subscription error:', error);
      onUpdate([]);
    });
  };
  export const subscribeToMessages = (
    conversationId: string,
    onUpdate: (messages: Message[]) => void
  ): Unsubscribe => {
    if (!isFirebaseConfigured()) return () => {};
    
    const q = query(
      collection(db, 'messages'),
      where('conversationId', '==', conversationId),
      orderBy('createdAt', 'asc')
    );
    
    return onSnapshot(q, (snapshot) => {
      const messages = snapshot.docs.map(doc => ({ 
        id: doc.id, 
        ...doc.data() 
      } as Message));
      onUpdate(messages);
    }, (error) => {
      console.error('Messages subscription error:', error);
      onUpdate([]);
    });
  };
  export const markMessagesAsRead = async (
    conversationId: string,
    userId: string
  ): Promise<void> => {
    if (!isFirebaseConfigured()) return;
    
    const q = query(
      collection(db, 'messages'),
      where('conversationId', '==', conversationId),
      where('read', '==', false)
    );
    
    const snapshot = await getDocs(q);
    const updates = snapshot.docs
      .filter(d => d.data().senderId !== userId)
      .map(d => updateDoc(d.ref, { read: true }));
    
    await Promise.all(updates);
  };
  export const getUnreadMessageCount = async (userId: string): Promise<number> => {
    if (!isFirebaseConfigured()) return 0;
    
    const convQuery = query(
      collection(db, 'conversations'),
      where('participants', 'array-contains', userId)
    );
    const convSnapshot = await getDocs(convQuery);
    const conversationIds = convSnapshot.docs.map(d => d.id);
    
    if (conversationIds.length === 0) return 0;
    
    let totalUnread = 0;
    
    for (const convId of conversationIds) {
      const msgQuery = query(
        collection(db, 'messages'),
        where('conversationId', '==', convId),
        where('read', '==', false)
      );
      const msgSnapshot = await getDocs(msgQuery);
      totalUnread += msgSnapshot.docs.filter(d => d.data().senderId !== userId).length;
    }
    
    return totalUnread;
  };
  // ========================
  // GITHUB VERIFICATION FUNCTIONS
  // ========================
  // ========================
// GITHUB VERIFICATION FUNCTIONS
// ========================

/**
 * Fetch GitHub user statistics using the GitHub API
 * @param username - GitHub username to fetch stats for
 * @param accessToken - GitHub OAuth access token
 * @returns GitHub stats object with publicRepos, followers, following
 * @throws Error if the fetch fails
 */
export const fetchGitHubStats = async (
  username: string,
  accessToken: string
): Promise<{ publicRepos: number; followers: number; following: number }> => {
  const response = await fetch(`https://api.github.com/users/${username}`, {
    headers: {
      Authorization: `Bearer ${accessToken}`,
      Accept: 'application/vnd.github.v3+json',
    },
  });

  if (!response.ok) {
    const errorText = await response.text();
    console.error('[fetchGitHubStats] Failed:', response.status, errorText);
    throw new Error(`Failed to fetch GitHub stats: ${response.status}`);
  }

  const data = await response.json();

  return {
    publicRepos: data.public_repos ?? 0,
    followers: data.followers ?? 0,
    following: data.following ?? 0,
  };
};
  // ========================
  // USERNAME FUNCTIONS
  // ========================
  export const isUsernameAvailable = async (username: string, excludeUserId?: string): Promise<boolean> => {
    if (!isFirebaseConfigured()) return true;
    if (!username) return false;
    
    const normalizedUsername = username.toLowerCase();
    
    const q = query(
      collection(db, 'profiles'),
      where('username', '==', normalizedUsername)
    );
    
    const snapshot = await getDocs(q);
    
    if (snapshot.empty) return true;
    
    if (excludeUserId) {
      return snapshot.docs.every(doc => doc.id === excludeUserId);
    }
    
    return false;
  };
  export const getUserEmailByUsername = async (username: string): Promise<string | null> => {
    if (!isFirebaseConfigured()) return null;
    
    const normalizedUsername = username.toLowerCase().replace('@', '');
    
    const q = query(
      collection(db, 'profiles'),
      where('username', '==', normalizedUsername),
      limit(1)
    );
    
    const snapshot = await getDocs(q);
    
    if (snapshot.empty) return null;
    
    const profile = snapshot.docs[0].data();
    return profile.email || null;
  };
  export const generateUniqueUsername = async (fullName: string): Promise<string> => {
    if (!isFirebaseConfigured()) return '';
    
    let attempts = 0;
    const maxAttempts = 10;
    
    while (attempts < maxAttempts) {
      const username = generateUsernameFromName(fullName);
      const normalizedUsername = username.toLowerCase();
      
      const isAvailable = await isUsernameAvailable(normalizedUsername);
      
      if (isAvailable && isValidUsername(normalizedUsername)) {
        return normalizedUsername;
      }
      
      attempts++;
    }
    
    const fallback = `user${Date.now().toString(36)}`;
    return fallback;
  };
  export const updateUsername = async (userId: string, newUsername: string): Promise<{ success: boolean; error?: string }> => {
    if (!isFirebaseConfigured()) return { success: false, error: 'Firebase not configured' };
    
    const normalizedUsername = newUsername.toLowerCase();
    
    if (!isValidUsername(normalizedUsername)) {
      return { success: false, error: 'Invalid username format' };
    }
    
    const isAvailable = await isUsernameAvailable(normalizedUsername, userId);
    if (!isAvailable) {
      return { success: false, error: 'Username is already taken' };
    }
    
    await updateDoc(doc(db, 'profiles', userId), {
      username: normalizedUsername,
      updatedAt: serverTimestamp()
    });
    
    return { success: true };
  };
  export const ensureUserHasUsername = async (userId: string): Promise<string | null> => {
    if (!isFirebaseConfigured()) return null;
    
    const profile = await getProfile(userId);
    if (!profile) return null;
    
    if (profile.username) {
      return profile.username;
    }
    
    const username = await generateUniqueUsername(profile.fullName || 'User');
    
    await updateDoc(doc(db, 'profiles', userId), {
      username,
      updatedAt: serverTimestamp()
    });
    
    return username;
  };
  export const getProfileByUsername = async (username: string): Promise<UserProfile | null> => {
    if (!isFirebaseConfigured()) return null;
    
    const normalizedUsername = username.toLowerCase();
    
    const q = query(
      collection(db, 'profiles'),
      where('username', '==', normalizedUsername),
      limit(1)
    );
    
    const snapshot = await getDocs(q);
    
    if (snapshot.empty) return null;
    
    return { id: snapshot.docs[0].id, ...snapshot.docs[0].data() } as UserProfile;
  };

  export const declareTeamComplete = async (
  teamId: string,
  userId: string
) => {
  const teamRef = doc(db, 'teams', teamId);

  await updateDoc(teamRef, {
    status: 'complete',
    completedAt: serverTimestamp(),
    completedBy: userId
  });
};

  export interface TeamWithMembers extends Team {
    loadedMembers: (TeamMember & {
      profile: UserProfile | null;
    })[];
  }

  export async function fetchLatestGitHubVerification(userId: string) {
  const q = query(
    collection(db, 'skillVerifications'),
    where('userId', '==', userId),
    where('sources.github.oauthVerified', '==', true),
    orderBy('verifiedAt', 'desc'),
    limit(1)
  );

  const snap = await getDocs(q);
  return snap.empty ? null : snap.docs[0].data();
}




NANDISH'S FILES:

Profile.tsx:
import { useState, useEffect } from 'react';
import { Camera } from 'lucide-react';
import PitchModal from '../PitchModal';
import { MapPin, Calendar, Award, Quote, Sparkles, Shield, ExternalLink, Loader2, Edit, Trash2, PenSquare, CheckCircle2, ShieldCheck } from 'lucide-react';
import { useAuth } from '@/contexts/AuthContext';
import { 
  getProfile, 
  subscribeToUserPosts, 
  updatePost, 
  deletePost, 
  UserProfile, 
  updateProfile,
  FeedPost,
  getSkillVerification,
  subscribeToProfile,
  subscribeToSkillVerification,
  SkillVerification
} from '@/services/firestore';
import { isFirebaseConfigured } from '@/lib/firebase';
import { getSkillClass } from '@/data/mockData';
import { Timestamp } from 'firebase/firestore';
import EditPostModal from '../EditPostModal';
import { toast } from 'sonner';
import { deleteUserCompletely } from '@/services/firestore';
import { signOut } from 'firebase/auth';
import { auth } from '@/lib/firebase';
import { uploadProfilePicture } from '@/services/firestore';
import { deleteUser } from "firebase/auth";


interface ProfileProps {
  userId?: string;
  isOwnProfile?: boolean;
  userProfile?: UserProfile | null;
  onEditProfile?: () => void;
  onOpenVerification?: () => void;
  onMessage?: (userId: string) => void;
  onProfileUpdated?: (profile: UserProfile) => void;
}


const Profile = ({ userId, isOwnProfile = true, userProfile: passedProfile, onEditProfile, onOpenVerification, onMessage, onProfileUpdated }: ProfileProps) => {
  const { user } = useAuth();
  const [profile, setProfile] = useState<UserProfile | null>(passedProfile || null);
  const [loading, setLoading] = useState(!passedProfile);
  const [myPosts, setMyPosts] = useState<FeedPost[]>([]);
  const [postsLoading, setPostsLoading] = useState(true);
  const [editingPost, setEditingPost] = useState<FeedPost | null>(null);
  const [deletingPostId, setDeletingPostId] = useState<string | null>(null);
  const [showPitchModal, setShowPitchModal] = useState(false);

  
  // Skill verification state
  const [skillVerification, setSkillVerification] = useState<SkillVerification | null>(null);
  const [verificationLoading, setVerificationLoading] = useState(true);

  const targetUserId = userId || user?.uid;

  useEffect(() => {
    if (!targetUserId) return;

    const unsubscribe = subscribeToProfile(targetUserId, (updatedProfile) => {
      setProfile(updatedProfile);
      setLoading(false);
    });

    return () => unsubscribe();
  }, [targetUserId]);


  // Subscribe to user's posts
  useEffect(() => {
    if (!isFirebaseConfigured() || !targetUserId) {
      setPostsLoading(false);
      return;
    }

    const unsubscribe = subscribeToUserPosts(targetUserId, (posts) => {
      setMyPosts(posts);
      setPostsLoading(false);
    });

    return () => unsubscribe();
  }, [targetUserId]);

  // Subscribe to skill verification
  useEffect(() => {
    if (!isFirebaseConfigured() || !targetUserId) {
      setVerificationLoading(false);
      return;
    }

    const unsubscribe = subscribeToSkillVerification(targetUserId, (verification) => {
      setSkillVerification(verification);
      setVerificationLoading(false);
    });

    return () => unsubscribe();
  }, [targetUserId]);

  const handleEditPost = async (postId: string, data: { title: string; description: string; tags: string[] }) => {
    await updatePost(postId, data);
    toast.success('Post updated successfully!');
  };

  const handleDeletePost = async (postId: string) => {
    if (!confirm('Are you sure you want to delete this post? This action cannot be undone.')) {
      return;
    }
    
    setDeletingPostId(postId);
    try {
      await deletePost(postId);
      toast.success('Post deleted successfully!');
    } catch (error: any) {
      toast.error(error.message || 'Failed to delete post');
    }
    setDeletingPostId(null);
  };

  const handleDeleteProfile = async () => {
    const confirmText = prompt(
      "This will permanently delete your account.\nType DELETE to continue."
    );

    if (confirmText !== "DELETE") {
      toast("Deletion cancelled");
      return;
    }

    try {
      const currentUser = auth.currentUser;

      if (!currentUser) {
        throw new Error("No authenticated user");
      }

      // 1Ô∏è‚É£ Delete Firestore + Supabase data
      await deleteUserCompletely(currentUser.uid);

      // 2Ô∏è‚É£ Delete Firebase Auth user (MOST IMPORTANT)
      await deleteUser(currentUser);

      // 3Ô∏è‚É£ Redirect
      toast.success("Account deleted successfully");
      window.location.href = "/";
    } catch (err: any) {
      console.error(err);

      if (err.code === "auth/requires-recent-login") {
        toast.error("Please re-login to delete your account");
      } else {
        toast.error("Failed to delete account");
      }
    }
  };

  const handleAvatarChange = async (
    e: React.ChangeEvent<HTMLInputElement>
  ) => {
    if (!e.target.files || !user) return;

    const file = e.target.files[0];

    try {
      const avatarUrl = await uploadProfilePicture(user.uid, file);

      await updateProfile(user.uid, { avatar: avatarUrl });

      // üîë FETCH FRESH PROFILE & NOTIFY PARENT
      const updatedProfile = await getProfile(user.uid);
      if (updatedProfile) {
        onProfileUpdated?.(updatedProfile);
      }

      toast.success('Profile picture updated');
    } catch (err) {
      console.error('Upload failed:', err);
      toast.error('Upload failed');
    }
  };

  const formatTimestamp = (timestamp: Timestamp | null): string => {
    if (!timestamp) return 'Just now';
    const date = timestamp.toDate();
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);
    
    if (diffMins < 1) return 'Just now';
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    return `${diffDays}d ago`;
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center p-12">
        <Loader2 className="w-8 h-8 animate-spin text-primary" />
      </div>
    );
  }

  if (!profile) {
    return (
      <div className="card-base p-12 text-center">
        <p className="text-muted-foreground">Profile not found</p>
      </div>
    );
  }

  // Check if user has verified skills
  const totalProfileSkills = profile.skills?.length || 0;
const verifiedSkillsCount = skillVerification?.verifiedSkills.length || 0;

const hasVerifiedSkills =
  skillVerification?.status === 'verified' &&
  totalProfileSkills > 0 &&
  verifiedSkillsCount === totalProfileSkills;


  return (
    <div className="space-y-6">
      {/* Header Card */}
      <div className="card-base overflow-hidden">
        <div className="h-16 bg-gradient-to-r from-primary to-primary/70" />
        <div className="px-6 pb-6">
          <div className="flex flex-col md:flex-row md:items-end md:justify-between -mt-1 gap-4">
            <div className="flex items-end gap-4">
              <div className="relative">
  <img
    src={
      profile.avatar
        ? `${profile.avatar}?t=${Date.now()}`
        : `https://api.dicebear.com/7.x/initials/svg?seed=${encodeURIComponent(
            profile.fullName || 'User'
          )}`
    }
    className="avatar w-24 h-24 border-4 border-card cursor-pointer"
    onClick={() =>
      isOwnProfile &&
      document.getElementById('avatarInput')?.click()
    }
  />

  {/* Camera Icon */}
  {isOwnProfile && (
    <button
      onClick={() =>
        document.getElementById('avatarInput')?.click()
      }
      className="absolute bottom-1 right-1 bg-white p-1.5 rounded-full shadow hover:bg-gray-100 transition"
    >
      <Camera className="w-4 h-4 text-gray-700" />
    </button>
  )}
</div>
              {isOwnProfile && (
                <input
                  id="avatarInput"
                  type="file"
                  accept="image/*"
                  className="hidden"
                  onChange={handleAvatarChange}
                />
              )}
              <div className="mb-2">
                <div className="flex items-center gap-2 flex-wrap">
                  <h1 className="font-display font-bold text-2xl text-foreground">{profile.fullName}</h1>
                  {profile.username && (
                    <span className="text-sm text-muted-foreground">
                      @{profile.username}
                    </span>
                  )}
                  
                  {(hasVerifiedSkills || profile.teamId) && (
    <div className="flex items-center gap-2">
      {hasVerifiedSkills && (
        <span className="inline-flex items-center gap-1.5 px-2.5 py-1 rounded-full bg-[#1CB0A3]/70 border border-[#1CB0A3]/40 backdrop-blur-sm">
          <ShieldCheck className="w-4 h-4 text-white" />
          <span className="text-xs font-medium text-white">
            Skills Verified
          </span>
        </span>
      )}

      {profile.teamId && (
        <span className="inline-flex items-center gap-1.5 px-2.5 py-1 rounded-full bg-[#1CB0A3]/70 border border-[#1CB0A3]/40 backdrop-blur-sm">
          <Shield className="w-4 h-4 text-white" />
          <span className="text-xs font-medium text-white">
            In a Team
          </span>
        </span>
      )}
    </div>
  )}
</div>
                <p className="text-muted-foreground">{profile.primaryRole}</p>
                {profile.college && (
                  <p className="text-sm text-muted-foreground">{profile.college} ‚Ä¢ {profile.yearOfStudy}</p>
                )}

                {profile.city && (
                  <div className="flex items-center gap-1 text-sm text-muted-foreground mt-1">
                    <MapPin className="w-4 h-4" />
                    <span>{profile.city}</span>
                  </div>
                )}

              </div>
            </div>
            {isOwnProfile && onEditProfile && (
              <button onClick={onEditProfile} className="btn-secondary flex items-center gap-2">
                <Edit className="w-4 h-4" />
                Edit Profile
              </button>
            )}
            {!isOwnProfile && (
              <div className="flex items-center gap-2">
                <button className="btn-primary" onClick={() => setShowPitchModal(true)}>
                Pitch Your Team
                </button>

                <button onClick={() => onMessage?.(targetUserId!)}className="btn-secondary text-sm">
                Message
                </button>

              </div>
            )}
          </div>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Main Content */}
        <div className="lg:col-span-2 space-y-6">
          {/* Bio */}
          {profile.bio && (
            <div className="card-base p-6">
              <h2 className="section-title mb-3">About</h2>
              <p className="text-muted-foreground leading-relaxed">{profile.bio}</p>
            </div>
          )}

          {/* Skills with Verification Indicator */}
          {profile.skills && profile.skills.length > 0 && (
            <div className="card-base p-6">
              <div className="flex items-center justify-between mb-4">
                <h2 className="section-title">Skills</h2>
                {hasVerifiedSkills && (
                  <span className="text-xs text-skill-mobile flex items-center gap-1">
                    <ShieldCheck className="w-3 h-3" />
                    {verifiedSkillsCount} verified
                  </span>
                )}
              </div>
              <div className="flex flex-wrap gap-2">
                {profile.skills.map((skill, idx) => {
                  const isVerified = skillVerification?.verifiedSkills.some(
                    vs => vs.toLowerCase() === skill.name.toLowerCase()
                  );
                  
                  return (
                    <span 
                      key={idx} 
                      className={`skill-tag text-sm ${getSkillClass(skill.name)} ${isVerified ? 'ring-2 ring-skill-mobile' : ''}`}
                    >
                      {isVerified && <ShieldCheck className="w-3 h-3 inline mr-1" />}
                      {skill.name}
                      <span className="ml-1 opacity-70">({skill.proficiency})</span>
                    </span>
                  );
                })}
              </div>
            </div>
          )}

          {/* My Posts Section */}
          <div className="card-base p-6">
            <div className="flex items-center justify-between mb-4">
              <h2 className="section-title flex items-center gap-2">
                <PenSquare className="w-4 h-4" />
                {isOwnProfile ? 'My Posts' : 'Posts'}
              </h2>
              <span className="text-sm text-muted-foreground">
                {myPosts.length} {myPosts.length === 1 ? 'post' : 'posts'}
              </span>
            </div>
            
            {postsLoading ? (
              <div className="flex items-center justify-center p-8">
                <Loader2 className="w-6 h-6 animate-spin text-primary" />
              </div>
            ) : myPosts.length === 0 ? (
              <div className="text-center py-8">
                <PenSquare className="w-10 h-10 text-muted-foreground mx-auto mb-3" />
                <p className="text-muted-foreground">
                  {isOwnProfile ? "You haven't created any posts yet" : "No posts yet"}
                </p>
              </div>
            ) : (
              <div className="space-y-4">
                {myPosts.map((post) => (
                  <div key={post.id} className="p-4 rounded-lg bg-secondary/30 border border-border">
                    <div className="flex items-start justify-between gap-4">
                      <div className="flex-1 min-w-0">
                        <h3 className="font-semibold text-foreground mb-1">{post.title}</h3>
                        <p className="text-sm text-muted-foreground mb-2 line-clamp-2">{post.description}</p>
                        
                        {/* Tags */}
                        {post.tags && post.tags.length > 0 && (
                          <div className="flex flex-wrap gap-1 mb-2">
                            {post.tags.map((tag, idx) => (
                              <span key={idx} className="px-2 py-0.5 rounded-full text-xs font-medium bg-secondary text-muted-foreground">
                                #{tag}
                              </span>
                            ))}
                          </div>
                        )}
                        
                        <p className="text-xs text-muted-foreground">
                          {formatTimestamp(post.createdAt)}
                        </p>
                      </div>
                      
                      {/* Edit/Delete buttons - only for own posts */}
                      {isOwnProfile && user?.uid === post.authorId && (
                        <div className="flex items-center gap-2 flex-shrink-0">
                          <button
                            onClick={() => setEditingPost(post)}
                            className="p-2 rounded-lg hover:bg-secondary transition-colors text-muted-foreground hover:text-foreground"
                            title="Edit post"
                          >
                            <Edit className="w-4 h-4" />
                          </button>
                          <button
                            onClick={() => handleDeletePost(post.id)}
                            disabled={deletingPostId === post.id}
                            className="p-2 rounded-lg hover:bg-destructive/10 transition-colors text-muted-foreground hover:text-destructive"
                            title="Delete post"
                          >
                            {deletingPostId === post.id ? (
                              <Loader2 className="w-4 h-4 animate-spin" />
                            ) : (
                              <Trash2 className="w-4 h-4" />
                            )}
                          </button>
                        </div>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>


        </div>

        {/* Sidebar */}
        <div className="space-y-6">
          {/* Status */}
          <div className="card-base p-6">
            <h2 className="section-title mb-4">Status</h2>
            <div className={`inline-flex items-center gap-2 px-3 py-1.5 rounded-full text-sm font-medium ${
              profile.teamId 
                ? 'bg-muted text-muted-foreground'
                : 'bg-skill-mobile/10 text-skill-mobile'
            }`}>
              <span className={`w-2 h-2 rounded-full ${
                profile.teamId 
                  ? 'bg-muted-foreground'
                  : 'bg-skill-mobile'
              }`} />
              {profile.teamId ? 'Currently in a team' : 'Available for teams'}
            </div>
          </div>

          {/* Education */}
          {profile.college && (
            <div className="card-base p-6">
              <h2 className="section-title mb-4">Education</h2>
              <div className="space-y-2">
                <p className="font-medium text-foreground">{profile.college}</p>
                <p className="text-sm text-muted-foreground">{profile.yearOfStudy}</p>
              </div>
            </div>
          )}

          {/* Skill Verification */}
          <div className="card-base p-6">
            <div className="flex items-center gap-2 mb-3">
              <Sparkles className="w-4 h-4 text-primary" />
              <h2 className="section-title text-sm">Skill Verification</h2>
            </div>
            
            {verificationLoading ? (
              <div className="flex items-center justify-center p-4">
                <Loader2 className="w-5 h-5 animate-spin text-primary" />
              </div>
            ) : hasVerifiedSkills ? (
              <div className="space-y-3">
                <div className="p-3 rounded-lg bg-skill-mobile/10 border border-skill-mobile/20">
                  <div className="flex items-center gap-2 mb-2">
                    <CheckCircle2 className="w-4 h-4 text-skill-mobile" />
                    <p className="text-sm font-medium text-skill-mobile">Skills Verified</p>
                  </div>
                  <p className="text-xs text-muted-foreground mb-2">
                    Verified on {skillVerification.verifiedAt?.toDate().toLocaleDateString()}
                  </p>
                  <div className="flex flex-wrap gap-1">
                    {skillVerification.verifiedSkills.slice(0, 5).map((skill, idx) => (
                      <span key={idx} className="px-2 py-0.5 rounded text-xs bg-skill-mobile/20 text-skill-mobile">
                        {skill}
                      </span>
                    ))}
                    {skillVerification.verifiedSkills.length > 5 && (
                      <span className="text-xs text-muted-foreground px-2">
                        +{skillVerification.verifiedSkills.length - 5} more
                      </span>
                    )}
                  </div>
                </div>
                
                {/* Verification Sources */}
                <div className="text-xs text-muted-foreground space-y-1">
                  {skillVerification.sources.github && (
                    <div className="flex items-center gap-1">
                      <CheckCircle2 className="w-3 h-3 text-skill-mobile" />
                      <span>GitHub verified</span>
                    </div>
                  )}
                  {skillVerification.sources.certificates && skillVerification.sources.certificates.length > 0 && (
                    <div className="flex items-center gap-1">
                      <CheckCircle2 className="w-3 h-3 text-skill-mobile" />
                      <span>{skillVerification.sources.certificates.length} certificate(s) verified</span>
                    </div>
                  )}
                </div>
              </div>
            ) : isOwnProfile ? (
              <button
                onClick={onOpenVerification}
                className="w-full p-3 rounded-lg bg-gradient-to-r from-primary/10 to-accent/10 border border-primary/20 hover:from-primary/20 hover:to-accent/20 transition-all text-left"
              >
                <p className="text-sm font-medium text-primary mb-1">Verify Your Skills</p>
                <p className="text-xs text-muted-foreground">
                  Increase credibility with GitHub or certificates
                </p>
              </button>
            ) : (
              <div className="p-3 rounded-lg bg-secondary/50 border border-border">
                <p className="text-sm text-muted-foreground">
                  Skills not verified yet
                </p>
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Edit Post Modal */}
      {editingPost && (
        <EditPostModal
          post={editingPost}
          onClose={() => setEditingPost(null)}
          onSubmit={handleEditPost}
        />
      )}
      {showPitchModal && !isOwnProfile && (
  <PitchModal
    type="pitch"
    recipientName={profile.fullName}
    recipientId={targetUserId}
    onClose={() => setShowPitchModal(false)}
    onSend={async (message) => {
      console.log('Pitch sent:', message);
      // TODO: save pitch / send notification / message
    }}
  />
)}

  {isOwnProfile && (
  <div className="card-base p-6 border border-destructive/30">
    <h2 className="section-title text-destructive mb-2">
      Danger Zone
    </h2>

    <button
      onClick={handleDeleteProfile}
      className="w-full mt-3 p-3 rounded-lg bg-destructive text-white hover:bg-destructive/90 flex items-center justify-center gap-2"
    >
      <Trash2 className="w-4 h-4" />
      Delete Profile Permanently
    </button>

    <p className="text-xs text-muted-foreground mt-2">
      This action cannot be undone.
    </p>
  </div>
)}


    </div>
  );
};

export default Profile;

LeftSidebar.tsx:
import { Home, Users, UserPlus, FolderKanban, User, Bell, Sparkles, Crown, Search, ChevronLeft, ChevronRight, MessageCircle } from 'lucide-react';
import { UserProfile } from '../services/firestore';
import { cn } from '@/lib/utils';

interface LeftSidebarProps {
  currentPage: string;
  onNavigate: (page: string) => void;
  userProfile?: UserProfile | null;
  collapsed?: boolean;
  onToggleCollapse?: () => void;
}

const LeftSidebar = ({ currentPage, onNavigate, userProfile, collapsed = false, onToggleCollapse }: LeftSidebarProps) => {
  const navItems = [
    { id: 'feed', label: 'Home Feed', icon: Home },
    { id: 'discover', label: 'Discover People', icon: Users },
    { id: 'discover-teams', label: 'Discover Teams', icon: Search },
    { id: 'build', label: 'Build a Team', icon: UserPlus },
    { id: 'teams', label: 'My Teams', icon: FolderKanban },
    { id: 'messages', label: 'Messages', icon: MessageCircle },
    { id: 'notifications', label: 'Notifications', icon: Bell },
    { id: 'profile', label: 'My Profile', icon: User },
  ];

  const displayName = userProfile?.fullName || 'User';
  const displayRole = userProfile?.primaryRole || 'Team Member';
  const displayAvatar = userProfile?.avatar || `https://api.dicebear.com/7.x/initials/svg?seed=${encodeURIComponent(displayName)}`;

  return (
    <aside className={cn(
      "flex-shrink-0 transition-all duration-300 max-h-[calc(100vh-6rem)] overflow-y-auto scrollbar-thin scrollbar-thumb-border scrollbar-track-transparent",
      collapsed ? "w-16" : "w-72"
    )}>
      <div className="space-y-4 pb-4">
        {/* Collapse Toggle Button */}
        {onToggleCollapse && (
          <button
            onClick={onToggleCollapse}
            className={cn(
              "w-full flex items-center justify-center p-4 rounded-lg transition-all duration-200 sticky top-0 z-10",
              "bg-white border border-gray-300 text-gray-700 hover:bg-gray-50",
              "shadow-sm text-2xl font-bold"
            )}
            title={collapsed ? "Expand sidebar" : "Collapse sidebar"}
          >
            {collapsed ? "->" : "<-"}
          </button>
        )}

        {/* Profile Card */}
        <div className="card-base overflow-hidden">
          <div className={cn("bg-gradient-to-r from-primary to-primary/80", collapsed ? "h-8" : "h-16")} />
          <div className={cn("px-4 pb-4", collapsed && "px-2 pb-2")}>
            <div className={cn("-mt-8 flex flex-col items-center", collapsed && "-mt-4")}>
              <img 
                src={
                  userProfile?.avatar
                    ? `${userProfile.avatar}?t=${Date.now()}`
                    : `https://api.dicebear.com/7.x/initials/svg?seed=${encodeURIComponent(
                        userProfile?.fullName || 'User'
                      )}`
                }
                alt={displayName} 
                className={cn(
                  "avatar border-4 border-card transition-all",
                  collapsed ? "w-10 h-10" : "w-16 h-16"
                )} 
              />
              {!collapsed && (
                <>
                  <h3 className="mt-2 font-display font-bold text-foreground">{displayName}</h3>
                  <p className="text-sm text-muted-foreground">{displayRole}</p>
                  {userProfile?.isTeamLeader ? (
                    <div className="mt-3 flex items-center gap-1 px-2 py-0.5 rounded-full text-xs font-medium bg-accent/10 text-accent">
                      <Crown className="w-3 h-3" />
                      <span>Team Leader</span>
                    </div>
                  ) : userProfile?.teamId ? (
                    <div className="mt-3 flex items-center gap-1 px-2 py-0.5 rounded-full text-xs font-medium bg-primary/10 text-primary">
                      <FolderKanban className="w-3 h-3" />
                      <span>In a Team</span>
                    </div>
                  ) : (
                    <div className="mt-3 flex items-center gap-1 ai-badge">
                      <Sparkles className="w-3 h-3" />
                      <span>Available</span>
                    </div>
                  )}
                </>
              )}
            </div>
          </div>
        </div>

        {/* Navigation */}
        <nav className={cn("card-base", collapsed ? "p-1" : "p-2")}>
          {navItems.map((item) => (
            <button
              key={item.id}
              onClick={() => onNavigate(item.id)}
              className={cn(
                "nav-item w-full",
                currentPage === item.id && 'nav-item-active',
                collapsed && 'justify-center px-2'
              )}
              title={collapsed ? item.label : undefined}
            >
              <item.icon className="w-5 h-5 flex-shrink-0" />
              {!collapsed && <span>{item.label}</span>}
            </button>
          ))}
        </nav>

        {/* Quote */}
        {!collapsed && (
          <div className="card-base p-4">
            <p className="text-sm text-muted-foreground italic leading-relaxed">
              "Teams fail because of poor composition, not poor ideas."
            </p>
            <p className="mt-2 text-xs text-primary font-medium">‚Äî TeamUp Philosophy</p>
          </div>
        )}
      </div>
    </aside>
  );
};

export default LeftSidebar;

firestore.ts:
import { 
  collection, 
  doc, 
  getDoc, 
  getDocs, 
  setDoc, 
  updateDoc, 
  deleteDoc,
  query, 
  where, 
  orderBy,
  addDoc,
  serverTimestamp,
  onSnapshot,
  Unsubscribe,
  limit
} from 'firebase/firestore';
import { db, isFirebaseConfigured } from '@/lib/firebase';
import type { 
  UserProfile, 
  Team, 
  TeamMember, 
  Invitation, 
  WorkspaceLog,
  Notification,
  FeedPost,
  TeamTask,
  Message,
  Conversation,
  SkillVerification
} from '@/types/firestore.types';
import { supabase } from '@/lib/supabase';
import { generateUsernameFromName, isValidUsername } from '../utils/username';



// Re-export types for convenience
export type { UserProfile, Team, TeamMember, Invitation, WorkspaceLog, Notification, FeedPost, TeamTask, Message, Conversation, SkillVerification };

// ========================
// PROFILE FUNCTIONS
// ========================

export const getProfile = async (userId: string): Promise<UserProfile | null> => {
  if (!isFirebaseConfigured()) return null;
  const docRef = doc(db, 'profiles', userId);
  const docSnap = await getDoc(docRef);
  return docSnap.exists() ? { id: docSnap.id, ...docSnap.data() } as UserProfile : null;
};

export const createProfile = async (userId: string, data: Partial<UserProfile>): Promise<void> => {
  if (!isFirebaseConfigured()) return;
  await setDoc(doc(db, 'profiles', userId), {
    ...data,
    teamId: null,
    isTeamLeader: false,
    createdAt: serverTimestamp()
  });
};

export const updateProfile = async (
  userId: string,
  data: Partial<UserProfile>
): Promise<void> => {
  if (!isFirebaseConfigured()) return;
  if (!userId) throw new Error('User ID is required for profile update');

  const updateData: any = {
    ...data,
    updatedAt: serverTimestamp()
  };

  if (data.username !== undefined) {
    updateData.username = data.username.toLowerCase();
  }

  await updateDoc(doc(db, 'profiles', userId), updateData);
};


// ========================
// CITY FUNCTIONS
// ========================

export const getAvailableCities = async (): Promise<string[]> => {
  if (!isFirebaseConfigured()) return [];

  const snapshot = await getDocs(collection(db, 'profiles'));
  const cities = new Set<string>();

  snapshot.docs.forEach(doc => {
    const city = doc.data().city;
    if (city && typeof city === 'string') {
      cities.add(city.trim());
    }
  });

  return Array.from(cities).sort();
};


// ========================
// SKILL VERIFICATION FUNCTIONS
// ========================

export const getSkillVerification = async (userId: string): Promise<SkillVerification | null> => {
  if (!isFirebaseConfigured()) return null;
  
  const q = query(
    collection(db, 'skillVerifications'),
    where('userId', '==', userId),
    where('status', '==', 'verified'),
    orderBy('verifiedAt', 'desc'),
    limit(1)
  );
  
  const snapshot = await getDocs(q);
  if (snapshot.empty) return null;
  
  return { id: snapshot.docs[0].id, ...snapshot.docs[0].data() } as SkillVerification;
};

export const createSkillVerification = async (
  userId: string,
  data: Omit<SkillVerification, 'id' | 'userId' | 'verifiedAt'>
): Promise<string> => {
  if (!isFirebaseConfigured()) return '';
  
  // Invalidate any existing verifications
  const existing = await getSkillVerification(userId);
  if (existing) {
    await updateDoc(doc(db, 'skillVerifications', existing.id), {
      status: 'invalidated',
      invalidatedAt: serverTimestamp(),
      invalidationReason: 'manual'
    });
  }
  
  const docRef = await addDoc(collection(db, 'skillVerifications'), {
    ...data,
    userId,
    verifiedAt: serverTimestamp()
  });
  
  return docRef.id;
};

export const invalidateSkillVerification = async (
  userId: string,
  reason: 'profile_edited' | 'manual' | 'expired'
): Promise<void> => {
  if (!isFirebaseConfigured()) return;
  
  const verification = await getSkillVerification(userId);
  if (!verification) return;
  
  await updateDoc(doc(db, 'skillVerifications', verification.id), {
    status: 'invalidated',
    invalidatedAt: serverTimestamp(),
    invalidationReason: reason
  });
};

export const subscribeToSkillVerification = (
  userId: string,
  onUpdate: (verification: SkillVerification | null) => void
): Unsubscribe => {
  if (!isFirebaseConfigured()) return () => {};
  
  const q = query(
    collection(db, 'skillVerifications'),
    where('userId', '==', userId),
    where('status', '==', 'verified'),
    orderBy('verifiedAt', 'desc'),
    limit(1)
  );
  
  return onSnapshot(q, (snapshot) => {
    if (snapshot.empty) {
      onUpdate(null);
      return;
    }
    onUpdate({ id: snapshot.docs[0].id, ...snapshot.docs[0].data() } as SkillVerification);
  });
};

// ========================
// DISCOVER PEOPLE FUNCTIONS
// ========================

// Get ALL users (except current user) - for Discover People page
export const getAllUsers = async (excludeUserId?: string): Promise<UserProfile[]> => {
  if (!isFirebaseConfigured()) return [];
  const q = query(collection(db, 'profiles'), orderBy('createdAt', 'desc'));
  const snapshot = await getDocs(q);
  return snapshot.docs
    .map(doc => ({ id: doc.id, ...doc.data() } as UserProfile))
    .filter(user => user.id !== excludeUserId);
};

// Subscribe to all users in real-time
export const subscribeToAllUsers = (
  excludeUserId: string,
  onUpdate: (users: UserProfile[]) => void
): Unsubscribe => {
  if (!isFirebaseConfigured()) return () => {};
  
  const q = query(collection(db, 'profiles'), orderBy('createdAt', 'desc'));
  
  return onSnapshot(q, (snapshot) => {
    const users = snapshot.docs
      .map(doc => ({ id: doc.id, ...doc.data() } as UserProfile))
      .filter(user => user.id !== excludeUserId);
    onUpdate(users);
  });
};

// Get available users only (for backward compatibility)
export const getAvailableUsers = async (excludeUserId?: string): Promise<UserProfile[]> => {
  if (!isFirebaseConfigured()) return [];
  const q = query(collection(db, 'profiles'), where('teamId', '==', null));
  const snapshot = await getDocs(q);
  return snapshot.docs
    .map(doc => ({ id: doc.id, ...doc.data() } as UserProfile))
    .filter(user => user.id !== excludeUserId);
};

export const getAvailableUsersByRole = async (role: string, excludeUserId?: string): Promise<UserProfile[]> => {
  if (!isFirebaseConfigured()) return [];
  const q = query(
    collection(db, 'profiles'), 
    where('teamId', '==', null),
    where('primaryRole', '==', role)
  );
  const snapshot = await getDocs(q);
  return snapshot.docs
    .map(doc => ({ id: doc.id, ...doc.data() } as UserProfile))
    .filter(user => user.id !== excludeUserId);
};

export const getAvailableRoles = async (): Promise<string[]> => {
  if (!isFirebaseConfigured()) return [];
  const snapshot = await getDocs(collection(db, 'profiles'));
  const roles = new Set<string>();
  snapshot.docs.forEach(doc => {
    const data = doc.data();
    if (data.primaryRole) roles.add(data.primaryRole);
  });
  return Array.from(roles);
};

// Get users by city (Discover People filter)
export const getUsersByCity = async (
  city: string,
  excludeUserId?: string
): Promise<UserProfile[]> => {
  if (!isFirebaseConfigured()) return [];

  const q = query(
    collection(db, 'profiles'),
    where('city', '==', city),
    orderBy('createdAt', 'desc')
  );

  const snapshot = await getDocs(q);

  return snapshot.docs
    .map(doc => ({ id: doc.id, ...doc.data() } as UserProfile))
    .filter(user => user.id !== excludeUserId);
};

// Subscribe to users by city (real-time)
export const subscribeToUsersByCity = (
  city: string,
  excludeUserId: string,
  onUpdate: (users: UserProfile[]) => void
): Unsubscribe => {
  if (!isFirebaseConfigured()) return () => {};

  const q = query(
    collection(db, 'profiles'),
    where('city', '==', city),
    orderBy('createdAt', 'desc')
  );

  return onSnapshot(q, (snapshot) => {
    const users = snapshot.docs
      .map(doc => ({ id: doc.id, ...doc.data() } as UserProfile))
      .filter(user => user.id !== excludeUserId);

    onUpdate(users);
  });
};


// ========================
// TEAM FUNCTIONS
// ========================

export const createTeam = async (data: Omit<Team, 'id' | 'createdAt' | 'members'>): Promise<string> => {
  if (!isFirebaseConfigured()) return '';
  
  const leaderProfile = await getProfile(data.leaderId);
  const leaderName = leaderProfile?.fullName || 'User';
  
  const docRef = await addDoc(collection(db, 'teams'), {
    ...data,
    leaderName,
    members: [{ userId: data.leaderId, role: 'Team Leader', userName: leaderName }],
    createdAt: serverTimestamp()
  });
  
  // Update user's teamId and isTeamLeader
  await updateProfile(data.leaderId, { teamId: docRef.id, isTeamLeader: true });
  
  // Create feed post for team creation
  await createFeedPost({
    authorId: data.leaderId,
    authorName: leaderName,
    authorAvatar: leaderProfile?.avatar,
    authorRole: leaderProfile?.primaryRole,
    type: 'team_created',
    title: `üöÄ Created team: ${data.name}`,
    description: data.description,
    teamId: docRef.id,
    teamName: data.name,
    rolesNeeded: data.rolesNeeded
  });
  
  return docRef.id;
};

export const getTeam = async (teamId: string): Promise<Team | null> => {
  if (!isFirebaseConfigured()) return null;
  const docSnap = await getDoc(doc(db, 'teams', teamId));
  return docSnap.exists() ? { id: docSnap.id, ...docSnap.data() } as Team : null;
};

export const getUserTeams = async (userId: string): Promise<Team[]> => {
  if (!isFirebaseConfigured()) return [];
  
  // Get user's profile to check teamId
  const profile = await getProfile(userId);
  if (!profile?.teamId) return [];
  
  const team = await getTeam(profile.teamId);
  return team ? [team] : [];
};

// Subscribe to user's teams in real-time
export const subscribeToUserTeams = (
  userId: string,
  onUpdate: (teams: Team[]) => void
): Unsubscribe => {
  if (!isFirebaseConfigured()) return () => {};
  
  // First get user's teamId, then subscribe to that team
  const profileRef = doc(db, 'profiles', userId);
  
  return onSnapshot(profileRef, async (profileSnap) => {
    const profile = profileSnap.exists() ? profileSnap.data() as UserProfile : null;
    if (!profile?.teamId) {
      onUpdate([]);
      return;
    }
    
    const team = await getTeam(profile.teamId);
    onUpdate(team ? [team] : []);
  });
};

export const updateTeam = async (teamId: string, data: Partial<Team>): Promise<void> => {
  if (!isFirebaseConfigured()) return;
  await updateDoc(doc(db, 'teams', teamId), data);
};

// ========================
// TEAM MEMBER FUNCTIONS
// ========================

export const addTeamMember = async (teamId: string, userId: string, role: string): Promise<void> => {
  if (!isFirebaseConfigured()) return;
  
  // Check if user is already in a team
  const profile = await getProfile(userId);
  if (profile?.teamId) {
    throw new Error('User is already in a team');
  }
  
  // Get current team
  const team = await getTeam(teamId);
  if (!team) throw new Error('Team not found');
  
  // Check if team is full
  if (team.members.length >= team.maxMembers) {
    throw new Error('Team is full');
  }
  
  const userName = profile?.fullName || 'User';
  
  // Add member to team's members array
  const updatedMembers = [...(team.members || []), { userId, role, userName }];
  await updateTeam(teamId, { members: updatedMembers });
  
  // Update user's teamId
  await updateProfile(userId, { teamId, isTeamLeader: false });
  
  // Create feed post
  await createFeedPost({
    authorId: userId,
    authorName: userName,
    authorAvatar: profile?.avatar,
    authorRole: profile?.primaryRole,
    type: 'member_joined',
    title: `üéâ Joined team: ${team.name}`,
    description: `${userName} joined as ${role}`,
    teamId,
    teamName: team.name
  });
  
  // Also add to teamMembers collection for backward compatibility
  await addDoc(collection(db, 'teamMembers'), {
    teamId,
    userId,
    role,
    joinedAt: serverTimestamp()
  });
};

export const getTeamMembers = async (teamId: string): Promise<(TeamMember & { profile: UserProfile | null })[]> => {
  if (!isFirebaseConfigured()) return [];
  
  // Get team and its members array
  const team = await getTeam(teamId);
  if (!team) return [];
  
  // Fetch profiles for each member
  const members = await Promise.all(
    (team.members || []).map(async (member, index) => {
      const profile = await getProfile(member.userId);
      return {
        id: `${teamId}-${member.userId}`,
        teamId,
        userId: member.userId,
        role: member.role,
        joinedAt: team.createdAt,
        profile
      } as TeamMember & { profile: UserProfile | null };
    })
  );
  
  return members;
};

// Subscribe to team members in real-time
export const subscribeToTeamMembers = (
  teamId: string,
  onUpdate: (members: (TeamMember & { profile: UserProfile | null })[]) => void
): Unsubscribe => {
  if (!isFirebaseConfigured()) return () => {};
  
  const teamRef = doc(db, 'teams', teamId);
  
  return onSnapshot(teamRef, async (teamSnap) => {
    if (!teamSnap.exists()) {
      onUpdate([]);
      return;
    }
    
    const team = { id: teamSnap.id, ...teamSnap.data() } as Team;
    
    const members = await Promise.all(
      (team.members || []).map(async (member) => {
        const profile = await getProfile(member.userId);
        return {
          id: `${teamId}-${member.userId}`,
          teamId,
          userId: member.userId,
          role: member.role,
          joinedAt: team.createdAt,
          profile
        } as TeamMember & { profile: UserProfile | null };
      })
    );
    
    onUpdate(members);
  });
};

export const removeTeamMember = async (teamId: string, userId: string): Promise<void> => {
  if (!isFirebaseConfigured()) return;
  
  const team = await getTeam(teamId);
  if (!team) return;
  
  const updatedMembers = (team.members || []).filter(m => m.userId !== userId);
  await updateTeam(teamId, { members: updatedMembers });
  await updateProfile(userId, { teamId: null, isTeamLeader: false });
  
  // Also remove from teamMembers collection
  const q = query(
    collection(db, 'teamMembers'),
    where('teamId', '==', teamId),
    where('userId', '==', userId)
  );
  const snapshot = await getDocs(q);
  for (const doc of snapshot.docs) {
    await deleteDoc(doc.ref);
  }
};

// Terminate team (leader only)
export const terminateTeam = async (
  teamId: string,
  leaderId: string
): Promise<void> => {
  if (!isFirebaseConfigured()) return;

  const team = await getTeam(teamId);
  if (!team) return;

  if (team.leaderId !== leaderId) {
    throw new Error('Only team leader can terminate the team');
  }

  // 1Ô∏è‚É£ Update all member profiles (BEST EFFORT)
  await Promise.allSettled(
    team.members.map(member =>
      updateProfile(member.userId, {
        teamId: null,
        isTeamLeader: false
      })
    )
  );

  // 2Ô∏è‚É£ Delete teamMembers (BEST EFFORT)
  try {
    const membersQuery = query(
      collection(db, 'teamMembers'),
      where('teamId', '==', teamId)
    );
    const snapshot = await getDocs(membersQuery);
    await Promise.all(snapshot.docs.map(d => deleteDoc(d.ref)));
  } catch (err) {
    console.warn('[terminateTeam] teamMembers cleanup skipped');
  }

  // 3Ô∏è‚É£ Delete invitations (BEST EFFORT)
  try {
    const invitationsQuery = query(
      collection(db, 'invitations'),
      where('teamId', '==', teamId)
    );
    const snapshot = await getDocs(invitationsQuery);
    await Promise.all(snapshot.docs.map(d => deleteDoc(d.ref)));
  } catch (err) {
    console.warn('[terminateTeam] invitations cleanup skipped');
  }

  // 4Ô∏è‚É£ DELETE TEAM (SOURCE OF TRUTH)
  await deleteDoc(doc(db, 'teams', teamId));
};


// Subscribe to teams with open slots (for Discover Teams page)
export const subscribeToAvailableTeams = (
  onUpdate: (teams: Team[]) => void
): Unsubscribe => {
  if (!isFirebaseConfigured()) return () => {};
  
  const q = query(
    collection(db, 'teams'),
    where('status', '==', 'forming'),
    orderBy('createdAt', 'desc')
  );
  
  return onSnapshot(q, (snapshot) => {
    const teams = snapshot.docs
      .map(doc => ({ id: doc.id, ...doc.data() } as Team))
      .filter(team => team.members.length < team.maxMembers);
    onUpdate(teams);
  }, (error) => {
    console.error('Available teams subscription error:', error);
    onUpdate([]);
  });
};

// ========================
// INVITATION FUNCTIONS
// ========================

export const sendInvitation = async (data: Omit<Invitation, 'id' | 'status' | 'createdAt'>): Promise<void> => {
  if (!isFirebaseConfigured()) return;
  
  const isJoinRequest = data.type === 'join_request';
  
  // For invites, check if target user is already in a team
  if (!isJoinRequest) {
    const targetProfile = await getProfile(data.toUserId);
    if (targetProfile?.teamId) {
      throw new Error('User is already in a team');
    }
  }
  
  // For join requests, check if sender is already in a team
  if (isJoinRequest) {
    const senderProfile = await getProfile(data.fromUserId);
    if (senderProfile?.teamId) {
      throw new Error('You are already in a team');
    }
  }
  
  // Check for existing pending invitation/request
  const existingQuery = query(
    collection(db, 'invitations'),
    where('fromUserId', '==', data.fromUserId),
    where('teamId', '==', data.teamId),
    where('status', '==', 'pending')
  );
  const existingSnap = await getDocs(existingQuery);
  if (!existingSnap.empty) {
    throw new Error(isJoinRequest ? 'Join request already sent' : 'Invitation already sent');
  }
  
  // Create invitation/join request
  await addDoc(collection(db, 'invitations'), {
    ...data,
    status: 'pending',
    createdAt: serverTimestamp()
  });
  
  // Create notification
  const notifyUserId = isJoinRequest ? data.toUserId : data.toUserId;
  await createNotification({
    toUserId: notifyUserId,
    fromUserId: data.fromUserId,
    fromUserName: data.fromUserName,
    type: isJoinRequest ? 'JOIN_REQUEST' : 'INVITE',
    teamId: data.teamId,
    teamName: data.teamName,
    message: data.message
  });
};

export const getIncomingInvitations = async (userId: string): Promise<Invitation[]> => {
  if (!isFirebaseConfigured()) return [];
  const q = query(
    collection(db, 'invitations'),
    where('toUserId', '==', userId),
    where('status', '==', 'pending')
  );
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Invitation));
};

export const getOutgoingInvitations = async (userId: string): Promise<Invitation[]> => {
  if (!isFirebaseConfigured()) return [];
  const q = query(
    collection(db, 'invitations'),
    where('fromUserId', '==', userId)
  );
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Invitation));
};

export const respondToInvitation = async (
  invitationId: string, 
  status: 'accepted' | 'rejected',
  teamId?: string,
  userId?: string,
  role?: string
): Promise<void> => {
  if (!isFirebaseConfigured()) return;
  
  // Get invitation details
  const invRef = doc(db, 'invitations', invitationId);
  const invSnap = await getDoc(invRef);
  const invitation = invSnap.exists() ? { id: invSnap.id, ...invSnap.data() } as Invitation : null;
  
  if (!invitation) {
    throw new Error('Invitation not found');
  }
  
  const isJoinRequest = invitation.type === 'join_request';
  
  // Determine who is joining
  const joiningUserId = isJoinRequest ? invitation.fromUserId : invitation.toUserId;
  const joiningUserName = isJoinRequest ? invitation.fromUserName : invitation.toUserName;
  
  // If accepting, verify the joining user is not already in a team
  if (status === 'accepted') {
    const profile = await getProfile(joiningUserId);
    if (profile?.teamId) {
      throw new Error('User is already in a team');
    }
    
    // Check if team still has room
    const team = await getTeam(invitation.teamId);
    if (!team) {
      throw new Error('Team no longer exists');
    }
    if (team.members.length >= team.maxMembers) {
      throw new Error('Team is full');
    }
  }
  
  await updateDoc(invRef, { status });
  
  if (status === 'accepted') {
    const joiningProfile = await getProfile(joiningUserId);
    const joiningRole = joiningProfile?.primaryRole || role || 'Member';
    
    await addTeamMember(invitation.teamId, joiningUserId, joiningRole);
    
    // Notify the appropriate party
    const notifyUserId = isJoinRequest ? invitation.fromUserId : invitation.fromUserId;
    const responderProfile = await getProfile(isJoinRequest ? invitation.toUserId : invitation.toUserId);
    
    await createNotification({
      toUserId: notifyUserId,
      fromUserId: isJoinRequest ? invitation.toUserId : invitation.toUserId,
      fromUserName: responderProfile?.fullName || 'User',
      type: 'ACCEPTED',
      teamId: invitation.teamId,
      teamName: invitation.teamName,
      message: isJoinRequest 
        ? `Your request to join ${invitation.teamName} was accepted!`
        : `${joiningUserName} accepted your invitation to join ${invitation.teamName}`
    });
  } else if (status === 'rejected') {
    const notifyUserId = isJoinRequest ? invitation.fromUserId : invitation.fromUserId;
    const responderProfile = await getProfile(isJoinRequest ? invitation.toUserId : invitation.toUserId);
    
    await createNotification({
      toUserId: notifyUserId,
      fromUserId: isJoinRequest ? invitation.toUserId : invitation.toUserId,
      fromUserName: responderProfile?.fullName || 'User',
      type: 'REJECTED',
      teamId: invitation.teamId,
      teamName: invitation.teamName,
      message: isJoinRequest 
        ? `Your request to join ${invitation.teamName} was declined`
        : `${invitation.toUserName} declined your invitation to join ${invitation.teamName}`
    });
  }
};

// Subscribe to join requests for a team leader
export const subscribeToJoinRequests = (
  teamId: string,
  onUpdate: (requests: Invitation[]) => void
): Unsubscribe => {
  if (!isFirebaseConfigured()) return () => {};
  
  const q = query(
    collection(db, 'invitations'),
    where('teamId', '==', teamId),
    where('type', '==', 'join_request'),
    where('status', '==', 'pending')
  );
  
  return onSnapshot(q, (snapshot) => {
    const requests = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Invitation));
    onUpdate(requests);
  }, (error) => {
    console.error('Join requests subscription error:', error);
    onUpdate([]);
  });
};

// Subscribe to invitations in real-time
export const subscribeToInvitations = (
  userId: string,
  onUpdate: (incoming: Invitation[], outgoing: Invitation[]) => void
): Unsubscribe => {
  if (!isFirebaseConfigured()) return () => {};
  
  const incomingQuery = query(
    collection(db, 'invitations'),
    where('toUserId', '==', userId),
    where('status', '==', 'pending')
  );
  
  const outgoingQuery = query(
    collection(db, 'invitations'),
    where('fromUserId', '==', userId)
  );
  
  let incoming: Invitation[] = [];
  let outgoing: Invitation[] = [];
  
  const unsubIncoming = onSnapshot(incomingQuery, (snapshot) => {
    incoming = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Invitation));
    onUpdate(incoming, outgoing);
  });
  
  const unsubOutgoing = onSnapshot(outgoingQuery, (snapshot) => {
    outgoing = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Invitation));
    onUpdate(incoming, outgoing);
  });
  
  return () => {
    unsubIncoming();
    unsubOutgoing();
  };
};

// ========================
// NOTIFICATION FUNCTIONS
// ========================

export const createNotification = async (data: Omit<Notification, 'id' | 'read' | 'createdAt'>): Promise<void> => {
  if (!isFirebaseConfigured()) return;
  await addDoc(collection(db, 'notifications'), {
    ...data,
    read: false,
    createdAt: serverTimestamp()
  });
};

export const getNotifications = async (userId: string): Promise<Notification[]> => {
  if (!isFirebaseConfigured()) return [];
  const q = query(
    collection(db, 'notifications'),
    where('toUserId', '==', userId),
    orderBy('createdAt', 'desc'),
    limit(50)
  );
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Notification));
};

export const subscribeToNotifications = (
  userId: string,
  onUpdate: (notifications: Notification[]) => void
): Unsubscribe => {
  if (!isFirebaseConfigured()) return () => {};
  
  const q = query(
    collection(db, 'notifications'),
    where('toUserId', '==', userId),
    orderBy('createdAt', 'desc'),
    limit(50)
  );
  
  return onSnapshot(q, (snapshot) => {
    const notifications = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Notification));
    onUpdate(notifications);
  });
};

export const markNotificationAsRead = async (notificationId: string): Promise<void> => {
  if (!isFirebaseConfigured()) return;
  await updateDoc(doc(db, 'notifications', notificationId), { read: true });
};

export const markAllNotificationsAsRead = async (userId: string): Promise<void> => {
  if (!isFirebaseConfigured()) return;
  const q = query(
    collection(db, 'notifications'),
    where('toUserId', '==', userId),
    where('read', '==', false)
  );
  const snapshot = await getDocs(q);
  await Promise.all(snapshot.docs.map(d => updateDoc(d.ref, { read: true })));
};

export const getUnreadNotificationCount = async (userId: string): Promise<number> => {
  if (!isFirebaseConfigured()) return 0;
  const q = query(
    collection(db, 'notifications'),
    where('toUserId', '==', userId),
    where('read', '==', false)
  );
  const snapshot = await getDocs(q);
  return snapshot.size;
};

// ========================
// FEED POST FUNCTIONS
// ========================

export const createFeedPost = async (data: Omit<FeedPost, 'id' | 'createdAt'>): Promise<string> => {
  if (!isFirebaseConfigured()) return '';
  const docRef = await addDoc(collection(db, 'posts'), {
    ...data,
    createdAt: serverTimestamp()
  });
  return docRef.id;
};

export const createUserPost = async (
  userId: string,
  data: { title: string; description: string; tags?: string[] }
): Promise<string> => {
  if (!isFirebaseConfigured()) return '';
  
  const profile = await getProfile(userId);
  
  const docRef = await addDoc(collection(db, 'posts'), {
    authorId: userId,
    authorName: profile?.fullName || 'User',
    authorAvatar: profile?.avatar,
    authorRole: profile?.primaryRole,
    type: 'user_post',
    title: data.title,
    description: data.description,
    tags: data.tags || [],
    createdAt: serverTimestamp()
  });
  
  return docRef.id;
};

export const updatePost = async (
  postId: string,
  data: { title: string; description: string; tags?: string[] }
): Promise<void> => {
  if (!isFirebaseConfigured()) return;
  await updateDoc(doc(db, 'posts', postId), {
    title: data.title,
    description: data.description,
    tags: data.tags || []
  });
};

export const deletePost = async (postId: string): Promise<void> => {
  if (!isFirebaseConfigured()) return;
  await deleteDoc(doc(db, 'posts', postId));
};

export const getUserPosts = async (userId: string): Promise<FeedPost[]> => {
  if (!isFirebaseConfigured()) return [];
  const q = query(
    collection(db, 'posts'),
    where('authorId', '==', userId),
    orderBy('createdAt', 'desc')
  );
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as FeedPost));
};

export const subscribeToUserPosts = (
  userId: string,
  onUpdate: (posts: FeedPost[]) => void
): Unsubscribe => {
  if (!isFirebaseConfigured()) return () => {};
  
  const q = query(
    collection(db, 'posts'),
    where('authorId', '==', userId),
    orderBy('createdAt', 'desc')
  );
  
  return onSnapshot(q, (snapshot) => {
    const posts = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as FeedPost));
    onUpdate(posts);
  });
};

export const getFeedPosts = async (): Promise<FeedPost[]> => {
  if (!isFirebaseConfigured()) return [];
  const q = query(
    collection(db, 'posts'),
    orderBy('createdAt', 'desc'),
    limit(50)
  );
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as FeedPost));
};

export const subscribeToFeedPosts = (
  onUpdate: (posts: FeedPost[]) => void
): Unsubscribe => {
  if (!isFirebaseConfigured()) return () => {};
  
  const q = query(
    collection(db, 'posts'),
    orderBy('createdAt', 'desc'),
    limit(50)
  );
  
  return onSnapshot(q, (snapshot) => {
    const posts = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as FeedPost));
    onUpdate(posts);
  }, (error) => {
    console.error('Feed subscription error:', error);
    onUpdate([]);
  });
};

// ========================
// WORKSPACE LOG FUNCTIONS
// ========================

export const addWorkspaceLog = async (teamId: string, userId: string, userName: string, message: string): Promise<void> => {
  if (!isFirebaseConfigured()) return;
  await addDoc(collection(db, 'workspaceLogs'), {
    teamId,
    userId,
    userName,
    message,
    createdAt: serverTimestamp()
  });
};

export const getWorkspaceLogs = async (teamId: string): Promise<WorkspaceLog[]> => {
  if (!isFirebaseConfigured()) return [];
  const q = query(
    collection(db, 'workspaceLogs'),
    where('teamId', '==', teamId),
    orderBy('createdAt', 'desc')
  );
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as WorkspaceLog));
};

export const subscribeToWorkspaceLogs = (
  teamId: string,
  onUpdate: (logs: WorkspaceLog[]) => void
): Unsubscribe => {
  if (!isFirebaseConfigured()) return () => {};
  
  const q = query(
    collection(db, 'workspaceLogs'),
    where('teamId', '==', teamId),
    orderBy('createdAt', 'desc')
  );
  
  return onSnapshot(q, (snapshot) => {
    const logs = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as WorkspaceLog));
    onUpdate(logs);
  });
};

// ========================
// TEAM TASK FUNCTIONS
// ========================

export const createTeamTask = async (
  teamId: string, 
  data: { title: string; assignedTo: string[]; completed: boolean }
): Promise<string> => {
  if (!isFirebaseConfigured()) return '';
  const docRef = await addDoc(collection(db, 'teamTasks'), {
    teamId,
    ...data,
    createdAt: serverTimestamp()
  });
  return docRef.id;
};

export const getTeamTasks = async (teamId: string): Promise<TeamTask[]> => {
  if (!isFirebaseConfigured()) return [];
  const q = query(
    collection(db, 'teamTasks'),
    where('teamId', '==', teamId),
    orderBy('createdAt', 'desc')
  );
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as TeamTask));
};

export const updateTeamTask = async (
  taskId: string,
  data: Partial<Pick<TeamTask, 'title' | 'assignedTo'>>
): Promise<void> => {
  if (!isFirebaseConfigured()) return;
  await updateDoc(doc(db, 'teamTasks', taskId), data);
};


export const subscribeToTeamTasks = (
  teamId: string,
  onUpdate: (tasks: TeamTask[]) => void
) => {
  const q = query(
    collection(db, 'teamTasks'),
    where('teamId', '==', teamId)
  );

  return onSnapshot(q, (snapshot) => {
    const tasks = snapshot.docs.map(doc => ({
      id: doc.id,
      ...(doc.data() as TeamTask),
    }));
    onUpdate(tasks);
  }, (error) => {
    console.error('Team tasks subscription error:', error);
    onUpdate([]);
  });
};


export const updateTaskCompletion = async (
  taskId: string, 
  completed: boolean, 
  completedBy: string
): Promise<void> => {
  if (!isFirebaseConfigured()) return;
  await updateDoc(doc(db, 'teamTasks', taskId), { 
    completed, 
    completedBy: completed ? completedBy : null,
    completedAt: completed ? serverTimestamp() : null
  });
};

export const deleteTeamTask = async (taskId: string): Promise<void> => {
  if (!isFirebaseConfigured()) return;
  await deleteDoc(doc(db, 'teamTasks', taskId));
};

// ========================
// STATS FUNCTIONS
// ========================

export const getAvailableUsersCount = async (): Promise<number> => {
  if (!isFirebaseConfigured()) return 0;
  const q = query(collection(db, 'profiles'), where('teamId', '==', null));
  const snapshot = await getDocs(q);
  return snapshot.size;
};

export const getAvailableTeamsCount = async (): Promise<number> => {
  if (!isFirebaseConfigured()) return 0;
  const q = query(collection(db, 'teams'), where('status', '==', 'forming'));
  const snapshot = await getDocs(q);
  return snapshot.size;
};

// ========================
// MESSAGING FUNCTIONS
// ========================

// Get or create a conversation between two users
export const getOrCreateConversation = async (
  user1Id: string,
  user2Id: string
): Promise<string> => {
  if (!isFirebaseConfigured()) return '';
  
  // Check if conversation already exists
  const q = query(
    collection(db, 'conversations'),
    where('participants', 'array-contains', user1Id)
  );
  
  const snapshot = await getDocs(q);
  const existing = snapshot.docs.find(doc => {
    const data = doc.data();
    return data.participants.includes(user2Id);
  });
  
  if (existing) {
    return existing.id;
  }
  
  // Get both user profiles
  const [profile1, profile2] = await Promise.all([
    getProfile(user1Id),
    getProfile(user2Id)
  ]);
  
  // Create new conversation
  const docRef = await addDoc(collection(db, 'conversations'), {
    participants: [user1Id, user2Id],
    participantNames: {
      [user1Id]: profile1?.fullName || 'User',
      [user2Id]: profile2?.fullName || 'User'
    },
    participantAvatars: {
      [user1Id]: profile1?.avatar || `https://api.dicebear.com/7.x/initials/svg?seed=${profile1?.fullName || 'User'}`,
      [user2Id]: profile2?.avatar || `https://api.dicebear.com/7.x/initials/svg?seed=${profile2?.fullName || 'User'}`
    },
    createdAt: serverTimestamp(),
    updatedAt: serverTimestamp()
  });
  
  return docRef.id;
};

// Send a message
// ========================
// MESSAGING FUNCTIONS (UPDATED WITH NOTIFICATIONS)
// ========================

// Send a message
export const sendMessage = async (
  conversationId: string,
  senderId: string,
  text: string
): Promise<string> => {
  if (!isFirebaseConfigured()) return '';

  const senderProfile = await getProfile(senderId);
  const convSnap = await getDoc(doc(db, 'conversations', conversationId));

  if (!convSnap.exists()) {
    throw new Error('Conversation not found');
  }

  const conversationData = convSnap.data();
  const { participants } = conversationData;

  // Create the message
  const messageRef = await addDoc(collection(db, 'messages'), {
    conversationId,
    participants,
    senderId,
    senderName: senderProfile?.fullName || 'User',
    text,
    read: false,
    createdAt: serverTimestamp()
  });

  // Update conversation's last message
  await updateDoc(doc(db, 'conversations', conversationId), {
    lastMessage: {
      text,
      senderId,
      sentAt: serverTimestamp()
    },
    updatedAt: serverTimestamp()
  });

  // ‚úÖ NEW: Create notification for the recipient
  const recipientId = participants.find((id: string) => id !== senderId);
  
  if (recipientId) {
    await createNotification({
      toUserId: recipientId,
      fromUserId: senderId,
      fromUserName: senderProfile?.fullName || 'User',
      type: 'MESSAGE',
      message: text.length > 50 ? text.substring(0, 50) + '...' : text,
      conversationId // Store conversation ID for navigation
    });
  }

  return messageRef.id;
};

// Subscribe to user's conversations
export const subscribeToConversations = (
  userId: string,
  onUpdate: (conversations: Conversation[]) => void
): Unsubscribe => {
  if (!isFirebaseConfigured()) return () => {};
  
  const q = query(
    collection(db, 'conversations'),
    where('participants', 'array-contains', userId),
    orderBy('updatedAt', 'desc')
  );
  
  return onSnapshot(q, (snapshot) => {
    const conversations = snapshot.docs.map(doc => ({ 
      id: doc.id, 
      ...doc.data() 
    } as Conversation));
    onUpdate(conversations);
  }, (error) => {
    console.error('Conversations subscription error:', error);
    onUpdate([]);
  });
};

// Subscribe to messages in a conversation
export const subscribeToMessages = (
  conversationId: string,
  onUpdate: (messages: Message[]) => void
): Unsubscribe => {
  if (!isFirebaseConfigured()) return () => {};
  
  const q = query(
    collection(db, 'messages'),
    where('conversationId', '==', conversationId),
    orderBy('createdAt', 'asc')
  );
  
  return onSnapshot(q, (snapshot) => {
    const messages = snapshot.docs.map(doc => ({ 
      id: doc.id, 
      ...doc.data() 
    } as Message));
    onUpdate(messages);
  }, (error) => {
    console.error('Messages subscription error:', error);
    onUpdate([]);
  });
};

// Mark messages as read
export const markMessagesAsRead = async (
  conversationId: string,
  userId: string
): Promise<void> => {
  if (!isFirebaseConfigured()) return;
  
  const q = query(
    collection(db, 'messages'),
    where('conversationId', '==', conversationId),
    where('read', '==', false)
  );
  
  const snapshot = await getDocs(q);
  const updates = snapshot.docs
    .filter(d => d.data().senderId !== userId)
    .map(d => updateDoc(d.ref, { read: true }));
  
  await Promise.all(updates);
};

// Get unread message count for a user
export const getUnreadMessageCount = async (userId: string): Promise<number> => {
  if (!isFirebaseConfigured()) return 0;
  
  // Get all conversations the user is part of
  const convQuery = query(
    collection(db, 'conversations'),
    where('participants', 'array-contains', userId)
  );
  const convSnapshot = await getDocs(convQuery);
  const conversationIds = convSnapshot.docs.map(d => d.id);
  
  if (conversationIds.length === 0) return 0;
  
  let totalUnread = 0;
  
  // For each conversation, count unread messages not sent by user
  for (const convId of conversationIds) {
    const msgQuery = query(
      collection(db, 'messages'),
      where('conversationId', '==', convId),
      where('read', '==', false)
    );
    const msgSnapshot = await getDocs(msgQuery);
    totalUnread += msgSnapshot.docs.filter(d => d.data().senderId !== userId).length;
  }
  
  return totalUnread;
};


// ========================
// GITHUB VERIFICATION FUNCTIONS
// ========================

/**
 * Fetch GitHub user statistics using the GitHub API
 * @param username - GitHub username to fetch stats for
 * @param accessToken - GitHub OAuth access token
 * @returns GitHub stats object with publicRepos, followers, following
 * @throws Error if the fetch fails
 */
export const fetchGitHubStats = async (
  username: string,
  accessToken: string
): Promise<{ publicRepos: number; followers: number; following: number }> => {
  const response = await fetch(`https://api.github.com/users/${username}`, {
    headers: {
      Authorization: `Bearer ${accessToken}`,
      Accept: 'application/vnd.github.v3+json',
    },
  });

  if (!response.ok) {
    const errorText = await response.text();
    console.error('[fetchGitHubStats] Failed:', response.status, errorText);
    throw new Error(`Failed to fetch GitHub stats: ${response.status}`);
  }

  const data = await response.json();

  return {
    publicRepos: data.public_repos ?? 0,
    followers: data.followers ?? 0,
    following: data.following ?? 0,
  };
};

export const deleteUserCompletely = async (userId: string) => {
  // 1. Get profile
  const profileRef = doc(db, 'profiles', userId);
  const profileSnap = await getDocs(query(collection(db, 'profiles'), where('__name__', '==', userId)));

  const profile = profileSnap.docs[0]?.data();
  if (!profile) return;

  // 2. Handle team
  if (profile.teamId) {
    const teamRef = doc(db, 'teams', profile.teamId);
    const teamSnap = await getDocs(query(collection(db, 'teams'), where('__name__', '==', profile.teamId)));

    const team = teamSnap.docs[0]?.data();

    if (team?.leaderId === userId) {
      // Delete team
      await deleteDoc(teamRef);
    } else {
      // Remove member
      const updatedMembers = team.members.filter((m: any) => m.userId !== userId);
      await updateDoc(teamRef, { members: updatedMembers });
    }
  }

  // 3. Delete user's posts
  const postsSnap = await getDocs(
    query(collection(db, 'posts'), where('authorId', '==', userId))
  );

  for (const docu of postsSnap.docs) {
    await deleteDoc(docu.ref);
  }

  // 4. Delete profile
  await deleteDoc(profileRef);
};

export const uploadProfilePicture = async (
  userId: string,
  file: File
) => {
  // ‚úÖ CORRECT PATH (NO DOUBLE avatars)
  const filePath = userId;

  const { error } = await supabase.storage
    .from('avatars')
    .upload(filePath, file, { upsert: true });

  if (error) {
    console.error('Supabase upload error:', error);
    throw error;
  }

  const { data } = supabase.storage
    .from('avatars')
    .getPublicUrl(filePath);

  // ‚úÖ SAVE URL TO FIRESTORE (SOURCE OF TRUTH)
  await updateDoc(doc(db, 'profiles', userId), {
    avatar: data.publicUrl,
    updatedAt: serverTimestamp()
  });

  return data.publicUrl;
};

export const subscribeToProfile = (
  userId: string,
  onUpdate: (profile: UserProfile | null) => void
) => {
  if (!isFirebaseConfigured()) return () => {};

  const ref = doc(db, 'profiles', userId);

  return onSnapshot(ref, (snap) => {
    if (!snap.exists()) {
      onUpdate(null);
      return;
    }
    onUpdate({ id: snap.id, ...snap.data() } as UserProfile);
  });
};

export const isUsernameAvailable = async (
  username: string,
  excludeUserId?: string
): Promise<boolean> => {
  if (!isFirebaseConfigured()) return true;
  if (!username) return false;

  const normalizedUsername = username.toLowerCase();

  const q = query(
    collection(db, 'profiles'),
    where('username', '==', normalizedUsername)
  );

  const snapshot = await getDocs(q);

  if (snapshot.empty) return true;

  if (excludeUserId) {
    return snapshot.docs.every(doc => doc.id === excludeUserId);
  }

  return false;
};

export const getUserEmailByUsername = async (
  username: string
): Promise<string | null> => {
  if (!isFirebaseConfigured()) return null;

  const normalizedUsername = username.toLowerCase().replace('@', '');

  const q = query(
    collection(db, 'profiles'),
    where('username', '==', normalizedUsername),
    limit(1)
  );

  const snapshot = await getDocs(q);
  if (snapshot.empty) return null;

  return snapshot.docs[0].data().email || null;
};

export const generateUniqueUsername = async (
  fullName: string
): Promise<string> => {
  if (!isFirebaseConfigured()) return '';

  let attempts = 0;
  while (attempts < 10) {
    const username = generateUsernameFromName(fullName);
    const normalized = username.toLowerCase();

    if (
      isValidUsername(normalized) &&
      await isUsernameAvailable(normalized)
    ) {
      return normalized;
    }

    attempts++;
  }

  return `user${Date.now().toString(36)}`;
};

export const updateUsername = async (
  userId: string,
  newUsername: string
): Promise<{ success: boolean; error?: string }> => {
  if (!isFirebaseConfigured()) {
    return { success: false, error: 'Firebase not configured' };
  }

  const normalized = newUsername.toLowerCase();

  if (!isValidUsername(normalized)) {
    return { success: false, error: 'Invalid username format' };
  }

  const available = await isUsernameAvailable(normalized, userId);
  if (!available) {
    return { success: false, error: 'Username is already taken' };
  }

  await updateDoc(doc(db, 'profiles', userId), {
    username: normalized,
    updatedAt: serverTimestamp()
  });

  return { success: true };
};

export const ensureUserHasUsername = async (
  userId: string
): Promise<string | null> => {
  if (!isFirebaseConfigured()) return null;

  const profile = await getProfile(userId);
  if (!profile) return null;

  if (profile.username) return profile.username;

  const username = await generateUniqueUsername(profile.fullName || 'User');

  await updateDoc(doc(db, 'profiles', userId), {
    username,
    updatedAt: serverTimestamp()
  });

  return username;
};

export const getProfileByUsername = async (
  username: string
): Promise<UserProfile | null> => {
  if (!isFirebaseConfigured()) return null;

  const normalized = username.toLowerCase();

  const q = query(
    collection(db, 'profiles'),
    where('username', '==', normalized),
    limit(1)
  );

  const snapshot = await getDocs(q);
  if (snapshot.empty) return null;

  return {
    id: snapshot.docs[0].id,
    ...snapshot.docs[0].data()
  } as UserProfile;
};

Index.tsx:
import { useState, useEffect } from 'react';
import { Zap, Menu, X, Bell, Search } from 'lucide-react';
import LeftSidebar from '../components/LeftSidebar';
import RightSidebar from '../components/RightSidebar';
import HomeFeed from '../components/pages/HomeFeed';
import BuildTeam from '../components/pages/BuildTeam';
import DiscoverPeople from '../components/pages/DiscoverPeople';
import DiscoverTeams from '../components/pages/DiscoverTeams';
import { toast } from 'sonner';
import MyTeams from '../components/pages/MyTeams';
import Profile from '../components/pages/Profile';
import Notifications from '../components/pages/Notifications';
import TeamWorkspace from '../components/pages/TeamWorkspace';
import Auth from '../components/pages/Auth';
import ProfileSetup from '../components/pages/ProfileSetup';
import SkillVerificationModal from '@/components/SkillVerificationModal';
import Messages from '@/components/pages/Messages';
import { useAuth } from '../contexts/AuthContext';
import { getProfile, subscribeToNotifications, getOrCreateConversation, UserProfile, Notification } from '../services/firestore';
import { isFirebaseConfigured } from '../lib/firebase';
import { useSidebarState } from '../hooks/useSidebarState';
import { useNavigate } from 'react-router-dom';
import Footer from "@/components/Footer";
import { AnimatePresence, motion } from "framer-motion";



const Index = () => {
  const { user, loading: authLoading, logout } = useAuth();
  const [currentPage, setCurrentPage] = useState('feed');
  const [selectedUserId, setSelectedUserId] = useState<string | null>(null);
  const [selectedTeamId, setSelectedTeamId] = useState<string | null>(null);
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
  const [profile, setProfile] = useState<UserProfile | null>(null);
  const [needsProfileSetup, setNeedsProfileSetup] = useState(false);
  const [editingProfile, setEditingProfile] = useState(false);
  const [unreadCount, setUnreadCount] = useState(0);
  const [showVerificationModal, setShowVerificationModal] = useState(false);
  const [activeConversationId, setActiveConversationId] = useState<string | null>(null);
  const [showLogoutConfirm, setShowLogoutConfirm] = useState(false);
  const { leftCollapsed, rightCollapsed, toggleLeft, toggleRight } = useSidebarState();
  const navigate = useNavigate();

  useEffect(() => {
  const savedPage = localStorage.getItem('teamup:lastPage');

  if (savedPage) {
    setCurrentPage(savedPage);
  }
}, []);



  useEffect(() => {
  const handlePopState = (event: PopStateEvent) => {
    if (event.state?.page) {
      setCurrentPage(event.state.page);
    } else {
      // Default fallback
      setCurrentPage('feed');
    }
  };

  window.addEventListener('popstate', handlePopState);
  return () => window.removeEventListener('popstate', handlePopState);
}, []);


  useEffect(() => {
    if (user && isFirebaseConfigured()) {
      checkProfile();

      // Subscribe to notifications for unread count
      const unsubscribe = subscribeToNotifications(user.uid, (notifications) => {
        const unread = notifications.filter(n => !n.read).length;
        setUnreadCount(unread);
      });
      return () => unsubscribe();
    }
  }, [user]);

  const checkProfile = async () => {
    if (!user) return;

    const userProfile = await getProfile(user.uid);

    // üî¥ FIX: profile does NOT exist ‚Üí account deleted / invalid
    if (!userProfile) {
      await logout();
      toast.error('Account not found or email not registered yet');
      return;
    }

    // Profile exists but incomplete ‚Üí setup allowed
    if (!userProfile.primaryRole) {
      setNeedsProfileSetup(true);
      return;
    }

    // Valid profile
    setProfile(userProfile);
    setNeedsProfileSetup(false);
  };

  const handleNavigate = (page: string) => {
  setCurrentPage(page);
  setSelectedUserId(null);
  setSelectedTeamId(null);
  setMobileMenuOpen(false);
  setEditingProfile(false);
  setActiveConversationId(null);

  // ‚úÖ Save last page
  localStorage.setItem('teamup:lastPage', page);

  // ‚úÖ Update browser history
  window.history.pushState({ page }, '', page === 'feed' ? '/' : `/${page}`);
};



  const handleViewProfile = (userId: string) => {
    setSelectedUserId(userId);
    setCurrentPage('viewProfile');
  };

  const handleMessageUser = async (targetUserId: string) => {
    if (!user) return;
    try {
      const conversationId = await getOrCreateConversation(user.uid, targetUserId);
      setActiveConversationId(conversationId);
      setCurrentPage('messages');
    } catch (error) {
      console.error('Error starting conversation:', error);
      toast.error('Failed to start conversation');
    }
  };

  const handleNavigateToMessages = (conversationId: string) => {
    setActiveConversationId(conversationId);
    setCurrentPage('messages');
  };

  const handleViewWorkspace = (teamId: string) => {
    setSelectedTeamId(teamId);
    setCurrentPage('workspace');
  };

  const handleEditProfile = () => {
    setEditingProfile(true);
  };

  const handleOpenVerification = () => {
    setShowVerificationModal(true);
  };

  const handleVerificationComplete = () => {
    setShowVerificationModal(false);
    checkProfile(); // Refresh profile to show verified status
  };
  // Show auth if not logged in (only when Firebase is configured)
  if (isFirebaseConfigured() && !authLoading && !user) {
    return <Auth onAuthSuccess={() => {}} />;
  }

  // Show loading
  if (authLoading) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <div className="text-center">
          <div className="p-2 rounded-lg bg-gradient-to-br from-primary to-primary/80 w-fit mx-auto mb-4">
            <Zap className="w-6 h-6 text-primary-foreground" />
          </div>
          <p className="text-muted-foreground">Loading...</p>
        </div>
      </div>
    );
  }

  // Show profile setup if needed
  if ((needsProfileSetup || editingProfile) && user) {
    return (
      <ProfileSetup
        existingProfile={editingProfile ? profile : null}
        onComplete={() => {
          setNeedsProfileSetup(false);
          setEditingProfile(false);
          checkProfile();
        }}
        onOpenVerification={handleOpenVerification}
      />
    );
  }

  const renderContent = () => {
    switch (currentPage) {
      case 'feed':
        return <HomeFeed onNavigate={handleNavigate} onViewProfile={handleViewProfile} />;

      case 'build':
        return <BuildTeam onNavigate={handleNavigate} />;

      case 'discover':
        return <DiscoverPeople onViewProfile={handleViewProfile} />;

      case 'discover-teams':
        return <DiscoverTeams onNavigate={handleNavigate} />;

      case 'teams':
  return (
    <MyTeams
      onNavigate={handleNavigate}
      onViewWorkspace={handleViewWorkspace}
      onViewProfile={handleViewProfile} // ‚úÖ CONNECTED
    />
  );


      case 'notifications':
        return <Notifications onNavigateToMessages={handleNavigateToMessages} />;

      case 'profile':
        return (
          <Profile
            isOwnProfile={true}
            userProfile={profile}
            onEditProfile={handleEditProfile}
            onOpenVerification={handleOpenVerification}
            onProfileUpdated={(updatedProfile) => {
              setProfile(updatedProfile); 
            }}
          />
        );

      case 'viewProfile':
        return (
          <Profile
            userId={selectedUserId || undefined}
            isOwnProfile={false}
            onMessage={handleMessageUser}
          />
        );

      case 'messages':
  return (
    <Messages
      initialConversationId={activeConversationId}
      onBack={() => handleNavigate('feed')}
      onViewProfile={handleViewProfile}
    />
  );

      case 'workspace':
        return (
          <TeamWorkspace
            teamId={selectedTeamId || ''}
            onBack={() => handleNavigate('teams')}
          />
        );

      default:
        return <HomeFeed onNavigate={handleNavigate} onViewProfile={handleViewProfile} />;
    }
  };

    return (
  <div className="min-h-screen bg-background flex flex-col">

    {/* Header */}
    <motion.header
  initial={{ y: -20, opacity: 0 }}
  animate={{ y: 0, opacity: 1 }}
  transition={{ duration: 0.25 }}
  className="sticky top-0 z-40 bg-card border-b border-border"
>
  
  <div className="max-w-7xl mx-auto px-4 h-16 flex items-center justify-between">
    
    {/* Logo */}
    <div
      onClick={() => handleNavigate('feed')}
      className="flex items-center gap-2 cursor-pointer select-none hover:opacity-80 transition"
    >
      <div className="p-1.5 rounded-lg bg-gradient-to-br from-primary to-primary/80">
        <Zap className="w-5 h-5 text-primary-foreground" />
      </div>
      <span className="font-display font-bold text-xl text-foreground">
        TeamUp
      </span>
    </div>

    {/* Right Actions */}
    <div className="flex items-center gap-3">
      
      {/* Notifications */}
      <button
        onClick={() => handleNavigate('notifications')}
        className="p-2 rounded-lg hover:bg-secondary transition-colors relative"
      >
        <Bell className="w-5 h-5 text-muted-foreground" />
        {unreadCount > 0 && (
          <span className="absolute top-0.5 right-0.5 min-w-[18px] h-[18px] px-1 rounded-full bg-accent text-accent-foreground text-xs font-bold flex items-center justify-center">
            {unreadCount > 9 ? '9+' : unreadCount}
          </span>
        )}
      </button>

      {/* Logout */}
      {user && (
<button
  onClick={() => setShowLogoutConfirm(true)}
  className="px-4 py-2 rounded-lg text-sm bg-destructive text-destructive-foreground hover:bg-destructive/90 transition"
>
  Logout
</button>


      )}

      {/* Mobile Menu */}
      <button
        onClick={() => setMobileMenuOpen(!mobileMenuOpen)}
        className="md:hidden p-2 rounded-lg hover:bg-secondary transition-colors"
      >
        {mobileMenuOpen ? (
          <X className="w-5 h-5 text-foreground" />
        ) : (
          <Menu className="w-5 h-5 text-foreground" />
        )}
      </button>
    </div>
  </div>

</motion.header>


      {/* header content unchanged */}

    {/* Mobile menu */}
    {mobileMenuOpen && (
      <div className="fixed inset-0 z-30 bg-background/95 backdrop-blur-sm md:hidden pt-16">
        <div className="p-4">
          <LeftSidebar
            currentPage={currentPage}
            onNavigate={handleNavigate}
            userProfile={profile}
          />
        </div>
      </div>
    )}

    {/* Main content (flex-1 pushes footer down) */}
    <div className="w-full px-4 py-6 flex-1">
      <div className="flex gap-6">
        <div className="hidden md:block">
          <div className="sticky top-24">
            <LeftSidebar
              currentPage={currentPage}
              onNavigate={handleNavigate}
              userProfile={profile}
              collapsed={leftCollapsed}
              onToggleCollapse={toggleLeft}
            />
          </div>
        </div>

        <main className="flex-1 min-w-0">
  <AnimatePresence mode="wait">
    <motion.div
      key={currentPage}
      initial={{ opacity: 0, y: 8 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: -6 }}
      transition={{ duration: 0.18, ease: "easeOut" }}
      className="h-full"
    >
      {renderContent()}
    </motion.div>
  </AnimatePresence>
</main>


        <div className="hidden lg:block">
          <div className="sticky top-24">
            <RightSidebar
              onViewProfile={handleViewProfile}
              onNavigate={handleNavigate}
              collapsed={rightCollapsed}
              onToggleCollapse={toggleRight}
            />
          </div>
        </div>
      </div>
    </div>

    {/* Modals */}
    {showVerificationModal && user && profile && (
      <SkillVerificationModal
        userId={user.uid}
        userName={profile.fullName}
        userSkills={profile.skills.map(skill => skill.name)}
        onClose={() => setShowVerificationModal(false)}
        onComplete={handleVerificationComplete}
      />
    )}

{showLogoutConfirm && (
  <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/40 backdrop-blur-sm">
    <motion.div
      initial={{ scale: 0.9, opacity: 0 }}
      animate={{ scale: 1, opacity: 1 }}
      exit={{ scale: 0.9, opacity: 0 }}
      transition={{ duration: 0.18, ease: "easeOut" }}
      className="bg-card rounded-xl shadow-lg w-full max-w-sm p-6"
    >
      <h2 className="text-lg font-semibold text-foreground mb-2">
        Confirm Logout
      </h2>

      <p className="text-sm text-muted-foreground mb-6">
        Do you really want to exit TeamUp?
      </p>

      <div className="flex justify-end gap-3">
        <button
          onClick={() => setShowLogoutConfirm(false)}
          className="px-4 py-2 rounded-lg text-sm bg-secondary text-foreground hover:bg-secondary/80 transition"
        >
          Cancel
        </button>

        <button
          onClick={async () => {
            try {
              setShowLogoutConfirm(false);
              await logout();

              setCurrentPage('feed');
              localStorage.removeItem('teamup:lastPage');

              window.location.href = '/';
            } catch (err) {
              console.error(err);
              toast.error('Failed to logout');
            }
          }}
          className="px-4 py-2 rounded-lg text-sm bg-destructive text-destructive-foreground hover:bg-destructive/90 transition"
        >
          Logout
        </button>
      </div>
    </motion.div>
  </div>
)}


    {/* ‚úÖ Footer ‚Äî ALWAYS LAST */}
    <footer className="w-full border-t border-border bg-background/80 backdrop-blur">
      <Footer />
    </footer>

  </div>
);
};
export default Index;

App.tsx:
import { BrowserRouter, Routes, Route } from "react-router-dom";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

import { Toaster } from "@/components/ui/toaster";
import { Toaster as Sonner } from "@/components/ui/sonner";
import { TooltipProvider } from "@/components/ui/tooltip";

import { AuthProvider } from "./contexts/AuthContext";
import { UserProfileProvider } from "./contexts/UserProfileContext";

import Index from "./pages/Index";
import NotFound from "./pages/NotFound";
import ProfilePage from "./pages/ProfilePage";
import TeamDetails from "./pages/TeamDetails";

const queryClient = new QueryClient();

const App = () => (
  <QueryClientProvider client={queryClient}>
    <AuthProvider>
      <UserProfileProvider>
        <TooltipProvider>
          <Toaster />
          <Sonner />
          <BrowserRouter>
            <Routes>
              <Route path="/" element={<Index />}>
                <Route path="team/:teamId" element={<TeamDetails />} />
              </Route>

              <Route path="/profile/:userId" element={<ProfilePage />} />
              <Route path="*" element={<NotFound />} />
            </Routes>
          </BrowserRouter>
        </TooltipProvider>
      </UserProfileProvider>
    </AuthProvider>
  </QueryClientProvider>
);

export default App;
